{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./lib/enemy.js","webpack:///./lib/game.js","webpack:///./lib/link.js","webpack:///./lib/schmelda.js","webpack:///./lib/wallmaster.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEe,oEAAK,EAAC;;;;;;;;;;;;;ACpErB;AAAA;AAAA;AAAyC;AACZ;;AAE7B;AACA;AACA;AACA,oBAAoB,gDAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,sDAAU;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,2BAA2B;AAC9C,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEe,mEAAI,EAAC;;;;;;;;;;;;;ACpGpB;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C,sBAAsB,yBAAyB;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,kBAAkB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA,kCAAkC,kBAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,mEAAI,EAAC;;;;;;;;;;;;;ACxapB;AAAA;AAA6B;;AAE7B;AACA;AACA;;AAEA,mBAAmB,gDAAI;AACvB;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACZD;AAAA;AAA4B;;AAE5B;AACA;AACA;AACA;;AAEA,yBAAyB,8CAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,yEAAU,EAAC","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./lib/schmelda.js\");\n","class Enemy {\n  constructor(canvas, ctx, pos) {\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.position = pos;\n\n    this.enemyDeathSound = new Audio('./assets/LTTP_Enemy_Kill.wav')\n\n  }\n\n  recoil(attackedSide) {\n    if (attackedSide === 0) {\n      this.position = [this.position[0] + 50, this.position[1]]\n    } else if (attackedSide === 1) {\n      this.position = [this.position[0] - 50, this.position[1]]\n    } else if (attackedSide === 2) {\n      this.position = [this.position[0], this.position[1] + 50]\n    } else {\n      this.position = [this.position[0], this.position[1] - 50]\n    };\n    this.ctx.fillStyle = 'red';\n    this.ctx.fill();\n  };\n\n  isDead() {\n    if (this.life === 0) {\n      this.enemyDeathSound.play();\n      return true;\n    }\n  };\n\n  hitbox() {\n    return {\n      x: this.position[0],\n      y: this.position[1],\n      width: this.width,\n      height: this.height,\n    }\n  };\n\n  collidedWith(object) {\n    let enemyHit = this.hitbox()\n    let objectHit = object.hitbox()\n    if (enemyHit.x < objectHit.x + objectHit.width && enemyHit.x + enemyHit.width > objectHit.x\n        && enemyHit.y < objectHit.y + objectHit.height && enemyHit.y + enemyHit.height > objectHit.y) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  moveAwayFromObject(object) {\n    if (object.position[0] < this.position[0]) {\n      this.position[0] += this.speed;\n    }\n    if (object.position[1] < this.position[1]) {\n      this.position[1] += this.speed;\n    }\n    if (object.position[0] > this.position[0]) {\n      this.position[0] -= this.speed;\n    }\n    if (object.position[1] > this.position[1]) {\n      this.position[1] -= this.speed;\n    }\n  };\n\n};\n\nexport default Enemy;\n","import Wallmaster from './wallmaster.js';\nimport Link from './link.js';\n\nclass Game {\n  constructor(canvas, ctx) {\n    this.enemies = [];\n    this.link = new Link(canvas, ctx);\n    this.ctx = ctx;\n    this.canvas = canvas;\n    this.draw = this.draw.bind(this);\n    this.makeEnemy = this.makeEnemy.bind(this);\n    this.loop = this.loop.bind(this);\n    this.linkHurtSound = new Audio('./assets/LTTP_Link_Hurt.wav');\n  }\n\n  loop() {\n    this.update();\n    this.draw();\n    window.requestAnimationFrame(this.loop)\n  }\n\n  update() {\n    this.gameOver();\n    this.avoidOverlap();\n    this.updateEnemies();\n  }\n\n  draw() {\n    this.link.draw();\n    this.drawEnemies();\n  }\n\n  updateEnemies() {\n    for (let i = 0; i < this.enemies.length; i++) {\n      //clear any dead enemies from the state\n      if (this.enemies[i].isDead()) {\n        this.enemies.splice(i, 1);\n      }\n      if (this.enemies[i]) {\n        this.enemies[i].move(this.link);\n        if (this.link.collidedWith(this.enemies[i]) && this.link.invincible === false) {\n          this.linkHurtSound.play();\n          // this.link.recoil();\n          this.link.life -= 1;\n          this.link.damaged();\n          console.log(this.link.life)\n        }\n        if (this.link.attackedObject(this.enemies[i])) {\n          this.enemies[i].recoil(this.link.currentDirection);\n          this.enemies[i].life -= 1\n        }\n      }\n    }\n  }\n\n  drawEnemies() {\n    for (let i = 0; i < this.enemies.length; i++) {\n      this.enemies[i].draw();\n    }\n  }\n\n  makeEnemy() {\n    if (this.enemies.length < 12) {\n      this.enemies.push(new Wallmaster(this.canvas, this.ctx, this.enemySpawnPos()));\n    }\n  }\n\n  enemySpawnPos() {\n    const wall = Math.floor(Math.random()*4);\n    switch (wall) {\n      case 0:\n        return [-50, Math.random()*this.canvas.height]\n      case 1:\n        return [this.canvas.width+50, Math.random()*this.canvas.height]\n      case 2:\n        return [Math.random()*this.canvas.width, this.canvas.height+ 50]\n      case 3:\n        return [Math.random()*this.canvas.width, -50]\n    }\n  }\n\n  avoidOverlap() {\n    for (let i = 0; i < this.enemies.length-1; i++) {\n      for (let j = i+1; j < this.enemies.length; j++) {\n        if (this.enemies[i].collidedWith(this.enemies[j])) {\n          this.enemies[i].moveAwayFromObject(this.enemies[j])\n          this.enemies[j].moveAwayFromObject(this.enemies[i])\n        }\n      }\n    }\n  }\n\n  gameOver() {\n    if (this.link.life === 0) {\n      // console.log(\"You have died!\")\n    }\n  }\n\n}\n\nexport default Game;\n","const directions = [\"walkRight\", \"walkLeft\", \"walkDown\", \"walkUp\"]\n\nconst WALK_X = {\n  \"walkRight\": [241, 271, 301, 331, 361, 391],\n  \"walkLeft\": [241, 271, 301, 331, 361, 391],\n  \"walkDown\": [0, 30, 60, 90, 120, 150, 180, 210],\n  \"walkUp\": [0, 30, 60, 90, 120, 150, 180, 210],\n};\n\nconst WALK_Y = {\n  \"walkRight\": 120,\n  \"walkLeft\": 30,\n  \"walkDown\": 30,\n  \"walkUp\": 120,\n};\n\nconst STANDING = [\n  [331, 120],\n  [151, 0],\n  [31, 0],\n  [210, 120],\n]; //right left down up\n\nconst attack_directions = [\"attackRight\", \"attackLeft\", \"attackDown\", \"attackUp\"]\n\nconst ATTACK_X = {\n  \"attackRight\": [242, 268, 295, 328, 360],\n  \"attackLeft\": [242, 268, 295, 327, 359],\n  \"attackDown\": [0, 30, 60, 90, 115, 145],\n  \"attackUp\": [0, 30, 60, 88, 115],\n}\n\nconst ATTACK_Y = {\n  \"attackRight\": [180, 180, 180, 180, 175],\n  \"attackLeft\": [90, 90, 90, 90, 84],\n  \"attackDown\": [90, 90, 86, 86, 86, 86],\n  \"attackUp\": [174, 177, 174, 177, 180],\n}\n\nconst ATTACK_WIDTHS = {\n  \"attackRight\": [18, 26, 31, 28, 23],\n  \"attackLeft\": [18, 26, 31, 28, 23],\n  \"attackDown\": [21, 22, 21, 20, 28, 33],\n  \"attackUp\": [21, 21, 21, 24, 35],\n}\n\nconst ATTACK_HEIGHTS = {\n  \"attackRight\": [23, 24, 22, 22, 31],\n  \"attackLeft\": [23, 24, 22, 22, 31],\n  \"attackDown\": [23, 24, 31, 31, 29, 27],\n  \"attackUp\": [22, 30, 35, 30, 23],\n}\n\nconst ATTACK_POS_OFFSET = {\n  \"attackRight\": [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],\n  \"attackLeft\": [[-2, 0], [-10, 0], [-13, 0], [-13, 0], [-7, 0]],\n  \"attackDown\": [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],\n  \"attackUp\": [[0, 0], [0, -7], [0, -8], [-4, -6], [-12, -1]],\n}\n\nclass Link {\n  constructor(canvas, ctx) {\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.link = new Image();\n    this.link.src = './assets/link_sprites.png';\n    this.width = 20;\n    this.height = 25;\n    this.scale = 1.5;\n    this.scaledWidth = this.scale*this.width;\n    this.scaledHeight = this.scale*this.height;\n    this.currentLoopIndex = 0;\n    this.currentAttackLoopIndex = 0;\n    this.currentDirection = 3;\n    this.position = [this.canvas.width/2 - this.scaledWidth/2, this.canvas.height*.6];\n    this.frameCount = 0;\n    this.attackFrameCount = 0;\n    this.life = 3;\n    this.attacking = false;\n    this.walking = false;\n    this.stunned = false;\n    this.invincible = false;\n\n    //sounds\n    this.swordSwingSounds = [\n      new Audio('./assets/LTTP_Sword1.wav'),\n      new Audio('./assets/LTTP_Sword2.wav')];\n    this.enemyHitSound = new Audio('./assets/LTTP_Enemy_Hit.wav');\n\n    // this.step = this.step.bind(this);\n    this.move = this.move.bind(this);\n    this.stand = this.stand.bind(this);\n    this.step = this.step.bind(this);\n    this.swing = this.swing.bind(this);\n    this.stopWalking = this.stopWalking.bind(this);\n    this.attack = this.attack.bind(this);\n    this.combineCallbacks = this.combineCallbacks.bind(this);\n    this.draw = this.draw.bind(this);\n    this.invincibility = this.invincibility.bind(this);\n  };\n\n  hitbox() {\n    return {\n      x: this.position[0],\n      y: this.position[1],\n      width: this.scaledWidth,\n      height: this.scaledHeight,\n    }\n  };\n\n  hurtbox() {\n    if (this.currentDirection === 0) {\n      return {\n        x: this.position[0] + this.scaledWidth,\n        y: this.position[1],\n        width: 8*this.scale,\n        height: this.scaledHeight,\n      }\n    } else if (this.currentDirection === 1) {\n      return {\n        x: this.position[0] - 8*this.scale,\n        y: this.position[1],\n        width: 8*this.scale,\n        height: this.scaledHeight,\n      }\n    } else if (this.currentDirection === 2) {\n      return {\n        x: this.position[0],\n        y: this.position[1] + this.scaledHeight,\n        width: this.scaledWidth,\n        height: 7*this.scale,\n      }\n    } else {\n      return {\n        x: this.position[0],\n        y: this.position[1] - 6*this.scale,\n        width: this.scaledWidth,\n        height: 6*this.scale,\n      }\n    }\n  }\n\n  collidedWith(object) {\n    let linkHit = this.hitbox()\n    let objectHit = object.hitbox()\n    if (\n      linkHit.x < objectHit.x + objectHit.width &&\n      linkHit.x + linkHit.width > objectHit.x &&\n      linkHit.y < objectHit.y + objectHit.height &&\n      linkHit.y + linkHit.height > objectHit.y\n      ) {\n        return true\n      } else {\n        return false\n    }\n  };\n\n  attackedObject(object) {\n    let swordHit = this.hurtbox()\n    let objectHit = object.hitbox()\n    if ( this.attacking &&\n      swordHit.x < objectHit.x + objectHit.width &&\n      swordHit.x + swordHit.width > objectHit.x &&\n      swordHit.y < objectHit.y + objectHit.height &&\n      swordHit.y + swordHit.height > objectHit.y\n      ) {\n        this.enemyHitSound.play();\n        return true\n      } else {\n        return false\n    }\n  }\n\n  recoil(attackedSide) {\n    if (attackedSide === 0) {\n      this.position = [this.position[0] + 70, this.position[1]]\n    } else if (attackedSide === 1) {\n      this.position = [this.position[0] - 70, this.position[1]]\n    } else if (attackedSide === 2) {\n      this.position = [this.position[0], this.position[1] + 70]\n    } else {\n      this.position = [this.position[0], this.position[1] - 70]\n    }\n\n  }\n\n  damaged() {\n    this.walking = false;\n    this.stunned = true;\n    this.invincible = true;\n    setTimeout(() => {this.stunned = false;}, 500) //stunned after hit\n    setTimeout(() => {this.invincible = false;}, 2000) //invincible for short time after getting hit\n  }\n\n  invincibility() {\n    if (this.invincible === true) {\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n      this.frameCount++\n      if (this.frameCount < 5) {\n        return;\n      }\n      this.frameCount = 0;\n\n      this.ctx.drawImage(\n        this.link,\n        STANDING[this.currentDirection][0],\n        STANDING[this.currentDirection][1],\n        this.width,\n        this.height,\n        this.position[0],\n        this.position[1],\n        this.scaledWidth,\n        this.scaledHeight,\n      );\n    }\n  }\n\n  oppositeDirection() {\n    switch (this.currentDirection) {\n      case 0:\n        return 1;\n      case 1:\n        return 0;\n      case 2:\n        return 3;\n      case 3:\n        return 2;\n    }\n  }\n\n  //moving\n\n  drawWalkFrame(direction, frame) {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.width)\n\n    this.ctx.drawImage(\n      this.link,\n      WALK_X[direction][frame],\n      WALK_Y[direction],\n      this.width,\n      this.height,\n      this.position[0],\n      this.position[1],\n      this.scaledWidth,\n      this.scaledHeight,\n    )\n    // this.ctx.beginPath();\n    // this.ctx.rect(this.position[0], this.position[1], this.scaledWidth, this.scaledHeight)\n    // this.ctx.lineWidth = 1\n    // this.ctx.strokeStyle = 'yellow';\n    // this.ctx.stroke();\n  };\n\n  step() {\n    if (this.walking === true) {\n      let numFrames = WALK_X[directions[this.currentDirection]].length\n      let cycleLoop = Array.from({length: numFrames}, (x,i) => i);\n\n      this.frameCount++\n      if (this.frameCount < 5) {\n        return;\n      }\n      this.frameCount = 0;\n\n      this.drawWalkFrame(\n        directions[this.currentDirection],\n        cycleLoop[this.currentLoopIndex],\n      );\n      this.currentLoopIndex++;\n      if (this.currentLoopIndex >= cycleLoop.length) {\n        this.currentLoopIndex = 0;\n      }\n    }\n  };\n\n  move(e) {\n    if (this.stunned) {\n      return\n    }\n    if (e.key === \"a\") {\n      this.walking = true\n      this.attacking = false;\n      this.position[0] -= 15;\n      this.currentDirection = 1;\n    } if (e.key === \"d\") {\n      this.walking = true\n      this.attacking = false;\n      this.position[0] += 15;\n      this.currentDirection = 0;\n    } if (e.key === \"s\") {\n      this.walking = true\n      this.attacking = false;\n      this.position[1] += 15;\n      this.currentDirection = 2;\n    } if (e.key === \"w\") {\n      this.walking = true\n      this.attacking = false;\n      this.position[1] -= 15;\n      this.currentDirection = 3;\n    }\n\n  };\n\n  //attacking\n\n  drawAttackFrame(direction, frame) {\n\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n    let attackPosX = this.position[0] + ATTACK_POS_OFFSET[direction][frame][0]*this.scale;\n    let attackPosY = this.position[1] + ATTACK_POS_OFFSET[direction][frame][1]*this.scale;\n    let attackWidth = ATTACK_WIDTHS[direction][frame]\n    let attackHeight = ATTACK_HEIGHTS[direction][frame];\n\n    this.ctx.drawImage(\n      this.link,\n      ATTACK_X[direction][frame],\n      ATTACK_Y[direction][frame],\n      attackWidth,\n      attackHeight,\n      attackPosX,\n      attackPosY,\n      attackWidth*this.scale,\n      attackHeight*this.scale,\n    )\n    // this.ctx.beginPath();\n    // this.ctx.rect(this.position[0], this.position[1], attackWidth*this.scale, attackHeight*this.scale)\n    // this.ctx.lineWidth = 1\n    // this.ctx.strokeStyle = 'yellow';\n    // this.ctx.stroke();\n\n\n  };\n\n  swing() {\n    if (this.attacking === true) {\n\n      let numFrames = ATTACK_X[attack_directions[this.currentDirection]].length\n      let cycleLoop = Array.from({length: numFrames}, (x,i) => i);\n      while (this.currentAttackLoopIndex <= cycleLoop.length) {\n        this.attackFrameCount++\n        if (this.attackFrameCount < 3) {\n          return;\n        }\n        this.attackFrameCount = 0;\n\n        if (this.currentAttackLoopIndex === cycleLoop.length) {\n          break;\n        }\n        this.drawAttackFrame(\n          attack_directions[this.currentDirection],\n          cycleLoop[this.currentAttackLoopIndex],\n        ),\n        this.currentAttackLoopIndex++;\n      }\n      this.currentAttackLoopIndex = 0;\n      this.walking = false;\n      this.attacking = false;\n    }\n  }\n\n  attack(e) {\n    if (this.stunned || this.attacking === true) {\n      return;\n    }\n    if(e.key === \"h\") {\n      console.log(\"swinging sword\");\n      const swordSoundIdx = Math.floor(Math.random()*2)\n      this.swordSwingSounds[swordSoundIdx].play();\n      this.walking = false;\n      this.attacking = true;\n    }\n  }\n\n  stand() {\n    if ((this.walking || this.attacking) === false) {\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n      this.ctx.drawImage(\n        this.link,\n        STANDING[this.currentDirection][0],\n        STANDING[this.currentDirection][1],\n        this.width,\n        this.height,\n        this.position[0],\n        this.position[1],\n        this.scaledWidth,\n        this.scaledHeight,\n      );\n    }\n  }\n\n  preventOffscreen() {\n    if (this.position[0] < 0) {\n      this.position[0] = 0\n    }\n    if (this.position[0] + this.scaledWidth > this.canvas.width) {\n      this.position[0] = this.canvas.width - this.scaledWidth\n    }\n    if (this.position[1] < 0) {\n      this.position[1] = 0\n    }\n    if (this.position[1] + this.scaledHeight > this.canvas.height) {\n      this.position[1] = this.canvas.height - this.scaledHeight\n    }\n  }\n\n  stopWalking(e) {\n    this.walking = false;\n  }\n\n  combineCallbacks(e) {\n    this.attack(e);\n    this.move(e);\n  }\n\n  draw() {\n    this.preventOffscreen();\n    this.swing();\n    this.step();\n    this.stand();\n    this.invincibility();\n  };\n}\n\nexport default Link;\n","import Game from './game.js';\n\ndocument.addEventListener('DOMContentLoaded', ()=> {\n  const mainCanvas = document.getElementById('main-window');\n  const ctx = mainCanvas.getContext('2d');\n\n  const game = new Game(mainCanvas, ctx)\n  setInterval(game.makeEnemy, 3000)\n  game.loop();\n  // document.onclick = game.link.attack;\n  document.onkeydown = game.link.combineCallbacks;\n  document.onkeyup = game.link.stopWalking;\n});\n","import Enemy from './enemy';\n\nconst WALLMASTER_SPRITES = [\n  [281, 883, 23, 23],\n  [323, 883, 23, 23]\n]\n\nclass Wallmaster extends Enemy {\n  constructor(canvas, ctx, pos) {\n    super(canvas, ctx, pos);\n    this.wallmaster = new Image();\n    this.wallmaster.src = './assets/enemies.png';\n    this.currentLoopIndex = 0;\n    this.walkCycle = 0;\n    this.frameCount = -1;\n    this.life = 3;\n    this.scale = 1.5;\n    this.speed = Math.random()*.8;\n    this.move = this.move.bind(this);\n    this.draw = this.draw.bind(this);\n  }\n\n  hitbox() {\n    return {\n      x: this.position[0],\n      y: this.position[1],\n      width: 23*this.scale,\n      height: 23*this.scale,\n    }\n  };\n\n  moveTowardsObject(object) {\n    if (object.position[0] < this.position[0]) {\n      this.position[0] -= this.speed;\n      this.currentDirection = 1;\n    }\n    if (object.position[1] < this.position[1]) {\n      this.position[1] -= this.speed;\n      this.currentDirection = 2;\n    }\n    if (object.position[0] > this.position[0]) {\n      this.position[0] += this.speed;\n      this.currentDirection = 0;\n    }\n    if (object.position[1] > this.position[1]) {\n      this.position[1] += this.speed;\n      this.currentDirection = 3;\n    }\n  }\n\n  move(player) {\n    // if (this.currentDirection === 0) {\n    //   this.position[0] += this.speed;\n    //   if (this.position[0] + this.width > this.canvas.width || this.position[0] < 0) {\n    //     this.currentDirection = 1\n    //   }\n    // } else if (this.currentDirection === 1) {\n    //   this.position[0] -= this.speed;\n    //   if (this.position[0] + this.width > this.canvas.width || this.position[0] < 0) {\n    //     this.currentDirection = 0\n    //   }\n    // }\n    this.moveTowardsObject(player)\n  }\n\n  getSprite() {\n    if (this.walkCycle === 0) {\n      return WALLMASTER_SPRITES[0]\n    } else {\n      return WALLMASTER_SPRITES[1]\n    }\n  }\n\n  draw() {\n    this.ctx.clearRect(this.position[0]-2, this.position[1]-2, this.width+4, this.height+4)\n    if (this.frameCount < 9) {\n      this.frameCount++\n    } else {\n      this.walkCycle = (this.walkCycle === 1 ? 0 : 1)\n      this.frameCount = 0;\n    }\n\n    let sprite = this.getSprite();\n\n    this.ctx.drawImage(\n      this.wallmaster,\n      sprite[0],\n      sprite[1],\n      sprite[2],\n      sprite[3],\n      this.position[0],\n      this.position[1],\n      this.scale*sprite[2],\n      this.scale*sprite[3],\n    )\n    // window.requestAnimationFrame(this.draw)\n  }\n}\n\nexport default Wallmaster;\n"],"sourceRoot":""}