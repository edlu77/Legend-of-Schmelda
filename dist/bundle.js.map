{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./lib/arrow.js","webpack:///./lib/arrow_item.js","webpack:///./lib/enemy.js","webpack:///./lib/game.js","webpack:///./lib/heart_item.js","webpack:///./lib/info.js","webpack:///./lib/item.js","webpack:///./lib/link.js","webpack:///./lib/moblin.js","webpack:///./lib/obstacle.js","webpack:///./lib/schmelda.js","webpack:///./lib/wallmaster.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEe,oEAAK,EAAC;;;;;;;;;;;;;ACtFrB;AAAA;AAA0B;;AAE1B;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,6CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEe,wEAAS,EAAC;;;;;;;;;;;;;ACxDzB;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEe,oEAAK,EAAC;;;;;;;;;;;;;ACpLrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyC;AACR;AACJ;AACE;AACS;AACA;AACH;AACR;;AAE7B;AACA;AACA;AACA;AACA,oBAAoB,gDAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gDAAI;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,oDAAQ;AACpC,4BAA4B,oDAAQ;AACpC,4BAA4B,oDAAQ;AACpC,4BAA4B,oDAAQ;AACpC,4BAA4B,oDAAQ;AACpC,4BAA4B,oDAAQ;AACpC,4BAA4B,oDAAQ;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,2BAA2B;AAC9C,qBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,kDAAM;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,sDAAS;AACnC,KAAK;AACL;AACA,0BAA0B,sDAAS;AACnC,KAAK;AACL;AACA;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;;AAEA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;;AAEA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP,6BAA6B,iDAAK;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,2BAA2B;AAC9C,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,mEAAI,EAAC;;;;;;;;;;;;;AChapB;AAAA;AAA0B;;AAE1B,wBAAwB,6CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEe,wEAAS,EAAC;;;;;;;;;;;;;AC7CzB;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEe,mEAAI,EAAC;;;;;;;;;;;;;AClEpB;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,sBAAsB;AAC5C;;AAEA;;AAEe,mEAAI,EAAC;;;;;;;;;;;;;ACfpB;AAAA;AAAA;AAAqC;AACG;;AAExC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C,sBAAsB,yBAAyB;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,kBAAkB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,mDAAS;AACjC;AACA,KAAK,0BAA0B,sDAAS;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,mEAAI,EAAC;;;;;;;;;;;;;ACxhBpB;AAAA;AAA4B;;AAE5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,8CAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEe,qEAAM,EAAC;;;;;;;;;;;;;ACrGtB;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,uEAAQ,EAAC;;;;;;;;;;;;;AClBxB;AAAA;AAAA;AAA6B;AACA;;AAE7B;AACA;AACA;AACA;AACA;;;AAGA,mBAAmB,gDAAI;AACvB,mBAAmB,gDAAI;AACvB;AACA;AACA,CAAC;;;;;;;;;;;;;ACdD;AAAA;AAA4B;;AAE5B;AACA;AACA;AACA;;AAEA,yBAAyB,8CAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,yEAAU,EAAC","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./lib/schmelda.js\");\n","const ARROW_SPRITES = [\n  [295, 376, 15, 5],\n  [194, 354, 15, 5],\n  [401, 104, 5, 15],\n  [395, 344, 5, 15],\n]\n\nclass Arrow {\n  constructor(canvas, ctx, pos, direction) {\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.position = pos;\n    this.scale = 1.5;\n    this.arrow = new Image();\n    this.arrow.src = './assets/link-2.gif';\n    this.direction = direction;\n    this.width = (this.direction === 0 || this.direction === 1) ? 15 : 5;\n    this.height = (this.direction === 1 || this.direction === 0) ? 5 : 15;\n\n    this.move = this.move.bind(this);\n  }\n\n  hitbox() {\n    return {\n      x: this.position[0],\n      y: this.position[1],\n      width: this.width,\n      height: this.height,\n    }\n  };\n\n  collidedWith(object) {\n    let enemyHit = this.hitbox()\n    let objectHit = object.hitbox()\n    if (enemyHit.x < objectHit.x + objectHit.width && enemyHit.x + enemyHit.width > objectHit.x\n        && enemyHit.y < objectHit.y + objectHit.height && enemyHit.y + enemyHit.height > objectHit.y) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  getSprite() {\n    return ARROW_SPRITES[this.direction]\n  }\n\n  move() {\n    if (this.direction === 0) {\n      this.position[0] += 5;\n    } else if (this.direction === 1) {\n      this.position[0] -= 5;\n    } else if (this.direction === 2) {\n      this.position[1] += 5;\n    } else {\n      this.position[1] -= 5;\n    }\n  }\n\n  draw() {\n    let sprite = this.getSprite();\n    this.ctx.drawImage(\n      this.arrow,\n      sprite[0],\n      sprite[1],\n      sprite[2],\n      sprite[3],\n      this.position[0],\n      this.position[1],\n      this.scale*sprite[2],\n      this.scale*sprite[3],\n    )\n  }\n\n  isOffscreen() {\n    if (\n      this.position[0] > this.canvas.width ||\n      this.position[0] + this.width < 0 ||\n      this.position[1] + this.height < 0 ||\n      this.position[1] > this.canvas.height) {\n      return true\n    } else {\n      return false\n    }\n  }\n}\n\nexport default Arrow;\n","import Item from './item';\n\nconst ARROW_ITEM_SPRITES = {\n  1: [192, 8, 16, 16],\n  5: [235, 8, 16, 16],\n  10: [259, 8, 16, 16],\n}\n\nclass ArrowItem extends Item {\n  constructor(canvas, ctx, pos, value) {\n    super(canvas, ctx, pos);\n    this.arrowItem = new Image();\n    this.arrowItem.src = './assets/items-overworld.png';\n    this.value = value;\n    this.width = 16;\n    this.height = 16;\n    this.weight = 10;\n  }\n\n  hitbox() {\n    return {\n      x: this.position[0],\n      y: this.position[1],\n      width: this.width*this.scale,\n      height: this.height*this.scale,\n    }\n  };\n\n  getSprite(){\n    return ARROW_ITEM_SPRITES[this.value]\n  }\n\n  draw() {\n    if (this.flashing) {\n      this.flashFrameCount++\n      if (this.flashFrameCount < 5) {\n        return;\n      }\n      this.flashFrameCount = 0;\n    }\n    const sprite = this.getSprite();\n    this.ctx.drawImage(\n      this.arrowItem,\n      sprite[0],\n      sprite[1],\n      sprite[2],\n      sprite[3],\n      this.position[0],\n      this.position[1],\n      this.scale*sprite[2],\n      this.scale*sprite[3],\n    )\n  }\n\n}\n\nexport default ArrowItem;\n","const DEATH_POOF = [\n  [79, 4, 24, 24],\n  [105, 4, 24, 24],\n  [131, 3, 24, 24],\n  [157, 4, 24, 24]\n]\n\nclass Enemy {\n  constructor(canvas, ctx, pos) {\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.position = pos;\n    this.scale = 2.6;\n    this.enemyDeathSound = new Audio('./assets/LTTP_Enemy_Kill.wav')\n    this.poofCurrentLoopIndex = 0;\n    this.poofFrameCount = 0;\n    this.deathPoof = new Image;\n    this.deathPoof.src = './assets/death-effects.png';\n    this.dead = false;\n    this.poofing = false;\n  }\n\n  recoil(attackedSide) {\n    if (attackedSide === 0) {\n      this.position = [this.position[0] + 50, this.position[1]]\n    } else if (attackedSide === 1) {\n      this.position = [this.position[0] - 50, this.position[1]]\n    } else if (attackedSide === 2) {\n      this.position = [this.position[0], this.position[1] + 50]\n    } else {\n      this.position = [this.position[0], this.position[1] - 50]\n    }\n  };\n\n  drawDeathPoof(frame) {\n    this.ctx.drawImage(\n      this.deathPoof,\n      frame[0],\n      frame[1],\n      frame[2],\n      frame[3],\n      this.position[0],\n      this.position[1],\n      frame[2]*this.scale,\n      frame[3]*this.scale,\n    )\n  }\n\n  poof() {\n    if (this.poofing) {\n      let currentFrame = DEATH_POOF[this.poofCurrentLoopIndex]\n      let numFrames = 4;\n      if (this.poofFrameCount < 5) {\n        this.drawDeathPoof(currentFrame),\n        this.poofFrameCount++;\n        return;\n      }\n      this.poofFrameCount = 0;\n      this.poofCurrentLoopIndex++;\n      if (this.poofCurrentLoopIndex >= numFrames) {\n        this.poofing = false;\n        this.poofCurrentLoopIndex = 0\n        return\n      }\n      this.drawDeathPoof(currentFrame)\n    }\n  }\n\n\n  isFullyDestroyed() {\n    if (this.poofing) {\n      return false;\n    } else if (this.dead) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  hitbox() {\n    return {\n      x: this.position[0],\n      y: this.position[1],\n      width: this.width*this.scale,\n      height: this.height*this.scale,\n    }\n  };\n\n  collidedWith(object) {\n    let enemyHit = this.hitbox()\n    let objectHit = object.hitbox()\n    if (enemyHit.x < objectHit.x + objectHit.width && enemyHit.x + enemyHit.width > objectHit.x\n        && enemyHit.y < objectHit.y + objectHit.height && enemyHit.y + enemyHit.height > objectHit.y) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  moveTowardsObject(object) {\n    if (this.poofing) {\n      return\n    }\n    let dx = Math.abs(object.position[0] - this.position[0]);\n    let dy = Math.abs(object.position[1] - this.position[1]);\n\n    if (object.position[0] < this.position[0]) {\n      this.position[0] -= this.speed;\n      if (dx > dy) {\n        this.currentDirection = 1;\n      }\n    }\n    if (object.position[1] < this.position[1]) {\n      this.position[1] -= this.speed;\n      if (dy > dx) {\n        this.currentDirection = 3;\n      }\n    }\n    if (object.position[0] > this.position[0]) {\n      this.position[0] += this.speed;\n      if (dx > dy) {\n        this.currentDirection = 0;\n      }\n    }\n    if (object.position[1] > this.position[1]) {\n      this.position[1] += this.speed;\n      if (dy > dx) {\n        this.currentDirection = 2;\n      }\n    }\n  }\n\n  moveAwayFromEnemy(enemy) {\n    if (this.poofing) {\n      return\n    }\n    if (enemy.position[0] < this.position[0]) {\n      this.position[0] += 1;\n    }\n    if (enemy.position[1] < this.position[1]) {\n      this.position[1] += 1;\n    }\n    if (enemy.position[0] > this.position[0]) {\n      this.position[0] -= 1;\n    }\n    if (enemy.position[1] > this.position[1]) {\n      this.position[1] -= 1;\n    }\n  }\n\n  moveAwayFromObject(object) {\n    const enemyHit = this.hitbox()\n    const objectHit = object.hitbox()\n\n    const linkBottom = enemyHit.y + enemyHit.height;\n    const objectBottom = objectHit.y + objectHit.height;\n    const linkRight = enemyHit.x + enemyHit.width;\n    const objectRight = objectHit.x + objectHit.width;\n\n    const bottomCollision = objectBottom - enemyHit.y;\n    const topCollision = linkBottom - objectHit.y;\n    const leftCollision = linkRight - objectHit.x;\n    const rightCollision = objectRight - enemyHit.x;\n\n    if (topCollision < bottomCollision && topCollision < leftCollision && topCollision < rightCollision ) {\n      this.position[1] = objectHit.y - enemyHit.height\n    }\n    if (bottomCollision < topCollision && bottomCollision < leftCollision && bottomCollision < rightCollision) {\n      this.position[1] = objectBottom\n    }\n    if (leftCollision < rightCollision && leftCollision < topCollision && leftCollision < bottomCollision) {\n      this.position[0] = objectHit.x - enemyHit.width\n    }\n    if (rightCollision < leftCollision && rightCollision < topCollision && rightCollision < bottomCollision ) {\n      this.position[0] = objectRight\n    }\n  };\n\n};\n\nexport default Enemy;\n","import Wallmaster from './wallmaster.js';\nimport Moblin from './moblin.js';\nimport Link from './link.js';\nimport Arrow from './arrow.js';\nimport ArrowItem from './arrow_item.js';\nimport HeartItem from './heart_item.js';\nimport Obstacle from './obstacle.js';\nimport Info from './info.js';\n\nclass Game {\n  constructor(canvas, ctx) {\n    this.enemies = [];\n    this.obstacles = [];\n    this.link = new Link(canvas, ctx);\n    this.ctx = ctx;\n    this.canvas = canvas;\n    this.keys = [];\n    this.arrows = [];\n    this.items = [];\n    this.oldTime = Date.now();\n    this.isGameOver = false;\n    this.score = 0;\n    this.canRestart = false;\n    this.currentMusic = null;\n    this.musicMuted = false;\n\n    this.hyruleTheme = new Audio('./assets/Hyrule_Field.mp3');\n    this.gameOverTheme = new Audio('./assets/Kakariko_Village.mp3');\n    this.arrowHitSound = new Audio('./assets/LTTP_Arrow_Hit.wav');\n    this.startGameSound = new Audio('./assets/LTTP_Secret.wav');\n\n    this.draw = this.draw.bind(this);\n    this.loop = this.loop.bind(this);\n    this.makeEnemy = this.makeEnemy.bind(this);\n    this.makeArrow = this.makeArrow.bind(this);\n    this.startGame = this.startGame.bind(this);\n    this.playTheme = this.playTheme.bind(this);\n    this.restartGame = this.restartGame.bind(this);\n    this.muteMusic = this.muteMusic.bind(this);\n    this.onMusic = this.onMusic.bind(this);\n  }\n\n  openMenu() {\n    this.setStartButton();\n  }\n\n  setStartButton() {\n    const startGameButton = document.getElementsByClassName('start-game-button')[0]\n    startGameButton.addEventListener('click', (e) => {\n      this.startGameSound.play();\n      this.openGameWindow();\n      setTimeout(this.startGame, 800);\n    });\n  }\n\n  openGameWindow() {\n    const mainMenu = document.getElementsByClassName('main-menu')[0];\n    mainMenu.className = 'main-menu close';\n    const gameOver = document.getElementsByClassName('game-over')[0];\n    gameOver.className = 'game-over close';\n    const gameWindow = document.getElementsByClassName('game-window')[0];\n    gameWindow.className = 'game-window';\n  }\n\n  playTheme() {\n    this.currentMusic = this.hyruleTheme;\n    this.gameOverTheme.pause();\n    this.hyruleTheme.play();\n  }\n\n  startGame() {\n    const musicOffButton = document.getElementsByClassName('music-button off')[0];\n    const musicOnButton = document.getElementsByClassName('music-button on')[0];\n    if (this.musicMuted) {\n      musicOffButton.className = 'music-button off hidden';\n      musicOnButton.className = 'music-button on';\n    } else {\n      musicOffButton.className = 'music-button off';\n      musicOnButton.className = 'music-button on hidden';\n    }\n    this.isGameOver = false;\n    this.canRestart = false;\n    this.arrows = [];\n    this.items = [];\n    this.enemies = [];\n    this.score = 0;\n    this.oldTime = Date.now();\n    this.link = new Link(this.canvas, this.ctx);\n    setTimeout(this.playTheme, 1000);\n    this.combineListeners();\n    this.makeObstacles();\n    this.loop()\n  }\n\n  stopGame() {\n    this.enemies = [];\n    const gameWindow = document.getElementsByClassName('game-window')[0];\n    gameWindow.className = 'game-window close';\n  }\n\n  gameOver() {\n    if (this.isGameOver) {\n      this.canRestart = true;\n      this.stopGame();\n      const gameOver = document.getElementsByClassName('game-over')[0];\n      gameOver.className = 'game-over';\n      this.hyruleTheme.pause();\n      this.currentMusic = this.gameOverTheme;\n      if (!this.musicMuted) {\n        this.gameOverTheme.play();\n      }\n    }\n  }\n\n  restartGame(e) {\n    if (this.canRestart) {\n      const restartButton = document.getElementsByClassName('restart-button')[0]\n      if (e.target === restartButton) {\n        this.startGameSound.play()\n        this.openGameWindow();\n        setTimeout(this.startGame, 800);\n      }\n    }\n  }\n\n  muteMusic(e) {\n    const musicOffButton = document.getElementsByClassName('music-button off')[0];\n    const musicOnButton = document.getElementsByClassName('music-button on')[0];\n    if (!this.musicMuted) {\n      if (e.target === musicOffButton) {\n        this.currentMusic.pause();\n        this.musicMuted = true;\n        musicOffButton.className = 'music-button off hidden';\n        musicOnButton.className = 'music-button on';\n      }\n    }\n  }\n\n  onMusic(e) {\n    const musicOnButton = document.getElementsByClassName('music-button on')[0];\n    const musicOffButton = document.getElementsByClassName('music-button off')[0];\n    if (this.musicMuted) {\n      if (e.target === musicOnButton) {\n        this.currentMusic.play();\n        this.musicMuted = false;\n        musicOnButton.className = 'music-button on hidden';\n        musicOffButton.className = 'music-button off';\n      }\n    }\n  }\n\n  combineListeners() {\n    document.addEventListener('keydown', this.link.getMoveKeys);\n    document.addEventListener('keydown', this.link.move);\n    document.addEventListener('keyup', this.link.deleteMoveKeys);\n    document.addEventListener('keyup', this.link.stopWalking);\n    document.addEventListener('keydown', this.link.attack);\n    document.addEventListener('keydown', this.link.useBow);\n    document.addEventListener('click', this.restartGame);\n    document.addEventListener('click', this.muteMusic);\n    document.addEventListener('click', this.onMusic);\n  }\n\n  makeObstacles() {\n    this.obstacles.push(new Obstacle([0, 0], 355, 23))\n    this.obstacles.push(new Obstacle([0, 32], 25, 72));\n    this.obstacles.push(new Obstacle([0, 193], 79, 48));\n    this.obstacles.push(new Obstacle([0, 241], 96, 11));\n    this.obstacles.push(new Obstacle([329, 29], 26, 72));\n    this.obstacles.push(new Obstacle([268, 195], 87, 57));\n    this.obstacles.push(new Obstacle([252, 244], 16, 8));\n  }\n\n  loop() {\n    if (!this.isGameOver) {\n      this.update();\n      this.draw();\n      window.requestAnimationFrame(this.loop)\n    }\n  }\n\n  update() {\n    this.handleObstacleCollisions();\n    this.makeEnemy();\n    this.updateEnemies();\n    this.avoidOverlap();\n    this.updateArrows();\n    this.makeArrow();\n    this.updateItems();\n    this.gameOver();\n  }\n\n  draw() {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n    this.link.draw();\n    this.drawEnemies();\n    this.drawArrows();\n    this.drawItems();\n    // this.drawObstacles();\n  }\n\n\n  // drawObstacles() {\n  //   for (var i = 0; i < this.obstacles.length; i++) {\n  //     this.ctx.beginPath();\n  //     this.ctx.rect(this.obstacles[i].hitbox().x, this.obstacles[i].hitbox().y, this.obstacles[i].hitbox().width, this.obstacles[i].hitbox().height)\n  //     this.ctx.lineWidth = 1\n  //     this.ctx.strokeStyle = 'yellow';\n  //     this.ctx.stroke();\n  //   }\n  // }\n\n  handleObstacleCollisions() {\n    for (let i = 0; i < this.obstacles.length; i++) {\n      for (let j = 0; j < this.enemies.length; j++) {\n        if (this.enemies[j].collidedWith(this.obstacles[i])) {\n          if (i === 0) {\n            return //enemies ignore the top block\n          }\n          this.enemies[j].moveAwayFromObject(this.obstacles[i]);\n        }\n      }\n      if (this.link.collidedWith(this.obstacles[i])) {\n        this.link.moveAwayFromObject(this.obstacles[i])\n      }\n    }\n  }\n\n  makeEnemy() {\n    if (Date.now() - this.oldTime > 2000 && this.enemies.length < 10 && !this.isGameOver) {\n      this.enemies.push(new Moblin(this.canvas, this.ctx, this.enemySpawnPos()));\n      console.log(\"new enemy\")\n      this.oldTime = Date.now();\n    }\n  }\n\n  dropItem(position) {\n    const roll = Math.random()*10;\n    if (roll < 1) {\n      this.items.push(new HeartItem(this.canvas, this.ctx, position, 1))\n    } else if (roll >= 1 && roll < 3) {\n      const amount = [1, 5, 10][Math.floor(Math.random()*3)]\n      this.items.push(new ArrowItem(this.canvas, this.ctx, position, amount))\n    } else {\n      return\n    }\n  }\n\n  updateEnemies() {\n    for (let i = 0; i < this.enemies.length; i++) {\n      this.handleDestroyed(this.enemies[i], i);\n      if (this.enemies[i]) {\n        this.enemies[i].move(this.link);\n        this.checkDealtDamage(this.enemies[i]);\n        this.checkAttacked(this.enemies[i]);\n        this.checkArrowHits(this.enemies[i]);\n      }\n    }\n  }\n\n  handleDestroyed(enemy, idx) {\n    if (enemy.isFullyDestroyed()) {\n      this.dropItem(\n        [enemy.position[0] + (enemy.scaledWidth/2),\n          enemy.position[1] + (enemy.scaledHeight/2)]\n      )\n      this.enemies.splice(idx, 1);\n      this.score++;\n    }\n  }\n\n  checkDealtDamage(enemy) {\n    if (this.link.collidedWith(enemy) && this.link.invincible === false && enemy.poofing === false) {\n      this.link.damaged();\n      if (this.link.life === 0) {\n        this.isGameOver = true;\n      }\n    }\n  }\n\n  checkAttacked(enemy) {\n    if (this.link.attackedObject(enemy)) {\n      enemy.life -= 1;\n      if (enemy.life <= 0) {\n        enemy.enemyDeathSound.play();\n        enemy.dead = true;\n        enemy.poofing = true;\n      } else {\n        enemy.recoil(this.link.currentDirection);\n      }\n    }\n  }\n\n  checkArrowHits(enemy) {\n    for (let j = 0; j < this.arrows.length; j++) {\n      if (enemy.collidedWith(this.arrows[j])) {\n        this.arrowHitSound.play();\n        enemy.life -= 1;\n        if (enemy.life <= 0) {\n          enemy.enemyDeathSound.play();\n          enemy.dead = true;\n          enemy.poofing = true;\n        } else {\n          enemy.recoil(this.arrows[j].direction);\n        }\n        this.arrows.splice(j, 1);\n      }\n    }\n  }\n\n  drawEnemies() {\n    for (let i = 0; i < this.enemies.length; i++) {\n      this.enemies[i].draw();\n    }\n  }\n\n  drawItems() {\n    for (let i = 0; i < this.items.length; i++) {\n      this.items[i].draw();\n    }\n  }\n\n  updateItems() {\n    for (let i = 0; i < this.items.length; i++) {\n      if (Date.now() - this.items[i].spawnTime > 10000) {\n        this.items.splice(i, 1);\n      }\n\n      if (this.items[i]) {\n        if (this.link.collidedWith(this.items[i])) {\n          this.link.pickUpItem(this.items[i]);\n          this.items.splice(i, 1);\n        }\n      }\n    }\n  }\n\n  makeArrow() {\n    if (this.link.firingBow) {\n      let startPos = this.link.position.slice(0);\n      if (this.link.currentDirection === 0) {\n        startPos[0] += this.link.scaledWidth;\n        startPos[1] += this.link.scaledHeight/2;\n      } else if (this.link.currentDirection === 1) {\n        startPos[0] -= 20;\n        startPos[1] = startPos[1] + this.link.scaledHeight/2;\n      } else if (this.link.currentDirection === 2) {\n        startPos[0] += this.link.scaledWidth/2;\n        startPos[1] += this.link.scaledHeight;\n      } else {\n        startPos[0] += this.link.scaledWidth/2;\n        startPos[1] -= 20;\n      }\n\n      if (this.arrowLimit()) {\n        return\n      } else {\n\n        this.arrows.push(new Arrow(this.canvas, this.ctx, startPos, this.link.currentDirection));\n        this.link.ammo -= 1;\n      }\n    }\n  }\n\n  arrowLimit() {\n    if (Date.now() - this.oldTime < 500) {\n      return true\n    }\n    this.oldTime = Date.now();\n  }\n\n  updateArrows() {\n    for (let i = 0; i < this.arrows.length; i++) {\n      if (this.arrows[i].isOffscreen()) {\n        this.arrows.splice(i, 1);\n      }\n      if (this.arrows[i]) {\n        this.arrows[i].move();\n      }\n    }\n  }\n\n  drawArrows() {\n    for (let i = 0; i < this.arrows.length; i++) {\n      this.arrows[i].draw();\n    }\n  }\n\n  enemySpawnPos() {\n    const spawnPoint = Math.floor(Math.random()*5);\n    switch (spawnPoint) {\n      case 0:\n        return [-50, (104 + Math.random()*21)*2] //left side\n      case 1:\n        return [this.canvas.width+50, (110 + Math.random()*20)*2] //right side\n      case 2:\n        return [(96 + Math.random()*63)*2, this.canvas.height+ 50] //bottom side\n      case 3:\n        return [111*2, 13*2] //left log\n      case 4:\n        return [223*2, 13*2] //right log\n    }\n  }\n\n  avoidOverlap() {\n    for (let i = 0; i < this.enemies.length-1; i++) {\n      for (let j = i+1; j < this.enemies.length; j++) {\n        if (this.enemies[i].collidedWith(this.enemies[j])) {\n          this.enemies[i].moveAwayFromEnemy(this.enemies[j])\n          this.enemies[j].moveAwayFromEnemy(this.enemies[i])\n        }\n      }\n    }\n  }\n}\n\nexport default Game;\n","import Item from './item';\n\nclass HeartItem extends Item {\n  constructor(canvas, ctx, pos, value) {\n    super(canvas, ctx, pos);\n    this.heartItem = new Image();\n    this.heartItem.src = './assets/items-overworld.png';\n    this.width = 14;\n    this.height = 13;\n    this.weight = 10;\n    this.scale = 2\n  }\n\n  hitbox() {\n    return {\n      x: this.position[0],\n      y: this.position[1],\n      width: this.width*this.scale,\n      height: this.height*this.scale,\n    }\n  };\n\n  draw() {\n    if (this.flashing) {\n      this.flashFrameCount++\n      if (this.flashFrameCount < 5) {\n        return;\n      }\n      this.flashFrameCount = 0;\n    }\n    this.ctx.drawImage(\n      this.heartItem,\n      273,\n      58,\n      this.width,\n      this.height,\n      this.position[0],\n      this.position[1],\n      this.width*this.scale,\n      this.height*this.scale,\n    )\n  }\n\n}\n\nexport default HeartItem;\n","class Info {\n  constructor(canvas, ctx, game) {\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.game = game;\n    this.heart = new Image();\n    this.heart.src = './assets/items-overworld.png';\n    this.bow = new Image();\n    this.bow.src = './assets/items-overworld.png';\n\n    this.draw = this.draw.bind(this);\n    this.loop = this.loop.bind(this);\n  }\n\n  draw() {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n    const score = `Score: ${this.game.score}`;\n    this.ctx.font = '40px returnofganon';\n    this.ctx.fillStyle = 'white';\n    this.ctx.textAlign = 'left';\n\n    this.drawHearts();\n    this.drawBow();\n    this.ctx.fillText(score, 10, 120);\n  }\n\n  drawHearts() {\n    const life = this.game.link.life;\n    for (let i = 0; i < life; i++) {\n      this.ctx.drawImage(\n        this.heart,\n        273,\n        58,\n        14,\n        13,\n        10 + i*35,\n        15,\n        28,\n        26,\n      )\n    }\n  }\n\n  drawBow() {\n    const arrows = `: ${this.game.link.ammo}`;\n    this.ctx.drawImage(\n      this.bow,\n      173,\n      9,\n      15,\n      15,\n      10,\n      50,\n      30,\n      30,\n    )\n    this.ctx.fillText(arrows, 45, 79)\n  }\n\n  loop() {\n    this.draw();\n    window.requestAnimationFrame(this.loop);\n  }\n}\n\nexport default Info;\n","class Item {\n  constructor(canvas, ctx, pos) {\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.position = pos;\n    this.scale = 2.6;\n    this.itemGetSound = new Audio('./assets/LTTP_Item.wav');\n    this.spawnTime = Date.now();\n    this.flashing = false;\n\n    setTimeout(() => {this.flashing = true;}, 7000)\n  }\n\n}\n\nexport default Item;\n","import ArrowItem from './arrow_item';\nimport HeartItem from './heart_item.js';\n\nconst directions = [\"walkRight\", \"walkLeft\", \"walkDown\", \"walkUp\"]\n\nconst WALK_X = {\n  \"walkRight\": [241, 271, 301, 331, 361, 391],\n  \"walkLeft\": [241, 271, 301, 331, 361, 391],\n  \"walkDown\": [0, 30, 60, 90, 120, 150, 180, 210],\n  \"walkUp\": [0, 30, 60, 90, 120, 150, 180, 210],\n};\n\nconst WALK_Y = {\n  \"walkRight\": 120,\n  \"walkLeft\": 30,\n  \"walkDown\": 30,\n  \"walkUp\": 120,\n};\n\nconst STANDING = [\n  [331, 120],\n  [151, 0],\n  [31, 0],\n  [210, 120],\n]; //right left down up\n\nconst attack_directions = [\"attackRight\", \"attackLeft\", \"attackDown\", \"attackUp\"]\n\nconst ATTACK_X = {\n  \"attackRight\": [242, 268, 295, 328, 360],\n  \"attackLeft\": [242, 268, 295, 327, 359],\n  \"attackDown\": [0, 30, 60, 90, 115, 145],\n  \"attackUp\": [0, 30, 60, 88, 115],\n}\n\nconst ATTACK_Y = {\n  \"attackRight\": [180, 180, 180, 180, 175],\n  \"attackLeft\": [90, 90, 90, 90, 84],\n  \"attackDown\": [90, 90, 86, 86, 86, 86],\n  \"attackUp\": [174, 177, 174, 177, 180],\n}\n\nconst ATTACK_WIDTHS = {\n  \"attackRight\": [18, 26, 31, 28, 23],\n  \"attackLeft\": [18, 26, 31, 28, 23],\n  \"attackDown\": [21, 22, 21, 20, 28, 33],\n  \"attackUp\": [21, 21, 21, 24, 35],\n}\n\nconst ATTACK_HEIGHTS = {\n  \"attackRight\": [23, 24, 22, 22, 31],\n  \"attackLeft\": [23, 24, 22, 22, 31],\n  \"attackDown\": [23, 24, 31, 31, 29, 27],\n  \"attackUp\": [22, 30, 35, 30, 23],\n}\n\nconst ATTACK_POS_OFFSET = {\n  \"attackRight\": [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],\n  \"attackLeft\": [[-2, 0], [-10, 0], [-13, 0], [-13, 0], [-7, 0]],\n  \"attackDown\": [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],\n  \"attackUp\": [[0, 0], [0, -7], [0, -8], [-4, -6], [-12, -1]],\n}\n\nconst bow_directions = [\"bowRight\", \"bowLeft\", \"bowDown\", \"bowUp\"];\n\nconst BOW_SPRITES = {\n  \"bowRight\": [\n    [117, 367, 20, 24],\n    [143, 367, 19, 24],\n    [169, 367, 17, 24],\n  ],\n  \"bowLeft\": [\n    [168, 342, 20, 24],\n    [143, 342, 19, 24],\n    [119, 342, 17, 24],\n  ],\n  \"bowDown\": [\n    [324, 95, 17, 24],\n    [348, 95, 18, 24],\n    [372, 95, 19, 24],\n  ],\n  \"bowUp\": [\n    [316, 342, 18, 22],\n    [338, 342, 21, 22],\n    [362, 342, 21, 22],\n  ],\n}\n\nclass Link {\n  constructor(canvas, ctx) {\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.link = new Image();\n    this.link.src = './assets/link_sprites.png';\n    this.link2 = new Image();\n    this.link2.src = './assets/link-2.gif';\n    this.width = 20;\n    this.height = 25;\n    this.scale = 2.6;\n    this.scaledWidth = this.scale*this.width;\n    this.scaledHeight = this.scale*this.height;\n    this.position = [this.canvas.width/2 - this.scaledWidth/2, this.canvas.height/2];\n    this.currentDirection = 2;\n    this.currentLoopIndex = 0;\n    this.attackCurrentLoopIndex = 0;\n    this.bowCurrentLoopIndex = 0;\n    this.frameCount = 0;\n    this.attackFrameCount = 0;\n    this.bowFrameCount = 0;\n    this.invFrameCount = 0;\n    this.keys = {};\n    this.attacking = false;\n    this.walking = false;\n    this.stunned = false;\n    this.invincible = false;\n    this.firingBow = false;\n    this.ammo = 5;\n    this.life = 3;\n\n    this.swordSwingSounds = [\n      new Audio('./assets/LTTP_Sword1.wav'),\n      new Audio('./assets/LTTP_Sword2.wav')];\n    this.arrowShootSound = new Audio('./assets/LTTP_Arrow_Shoot.wav');\n    this.enemyHitSound = new Audio('./assets/LTTP_Enemy_Hit.wav');\n    this.linkHurtSound = new Audio('./assets/LTTP_Link_Hurt.wav');\n    this.getItemSound = new Audio('./assets/LTTP_Item.wav');\n\n    this.move = this.move.bind(this);\n    this.attack = this.attack.bind(this);\n    this.useBow = this.useBow.bind(this);\n    this.stopWalking = this.stopWalking.bind(this);\n    this.getMoveKeys = this.getMoveKeys.bind(this);\n    this.deleteMoveKeys = this.deleteMoveKeys.bind(this);\n  };\n\n  hitbox() {\n    return {\n      x: this.position[0],\n      y: this.position[1],\n      width: this.scaledWidth,\n      height: this.scaledHeight,\n    }\n  };\n\n  hurtbox() {\n    if (this.currentDirection === 0) {\n      return {\n        x: this.position[0] + this.scaledWidth,\n        y: this.position[1] - 3*this.scale,\n        width: 11*this.scale,\n        height: this.scaledHeight + 6*this.scale,\n      }\n    } else if (this.currentDirection === 1) {\n      return {\n        x: this.position[0] - 11*this.scale,\n        y: this.position[1] - 3*this.scale,\n        width: 11*this.scale,\n        height: this.scaledHeight + 6*this.scale,\n      }\n    } else if (this.currentDirection === 2) {\n      return {\n        x: this.position[0] - 6.5*this.scale,\n        y: this.position[1] + this.scaledHeight,\n        width: this.scaledWidth + 13*this.scale,\n        height: 4*this.scale,\n      }\n    } else {\n      return {\n        x: this.position[0] - 7.5*this.scale,\n        y: this.position[1] - 15*this.scale,\n        width: this.scaledWidth + 15*this.scale,\n        height: 6*this.scale,\n      }\n    }\n  }\n\n  collidedWith(object) {\n    let linkHit = this.hitbox()\n    let objectHit = object.hitbox()\n    if (\n      linkHit.x < objectHit.x + objectHit.width &&\n      linkHit.x + linkHit.width > objectHit.x &&\n      linkHit.y < objectHit.y + objectHit.height &&\n      linkHit.y + linkHit.height > objectHit.y\n      ) {\n        return true\n      } else {\n        return false\n    }\n  };\n\n  moveAwayFromObject(object) {\n    const linkHit = this.hitbox()\n    const objectHit = object.hitbox()\n\n    const linkBottom = linkHit.y + linkHit.height;\n    const objectBottom = objectHit.y + objectHit.height;\n    const linkRight = linkHit.x + linkHit.width;\n    const objectRight = objectHit.x + objectHit.width;\n\n    const bottomCollision = objectBottom - linkHit.y;\n    const topCollision = linkBottom - objectHit.y;\n    const leftCollision = linkRight - objectHit.x;\n    const rightCollision = objectRight - linkHit.x;\n\n    if (topCollision < bottomCollision && topCollision < leftCollision && topCollision < rightCollision ) {\n      this.position[1] = objectHit.y - linkHit.height\n    }\n    if (bottomCollision < topCollision && bottomCollision < leftCollision && bottomCollision < rightCollision) {\n      this.position[1] = objectBottom\n    }\n    if (leftCollision < rightCollision && leftCollision < topCollision && leftCollision < bottomCollision) {\n      this.position[0] = objectHit.x - linkHit.width\n    }\n    if (rightCollision < leftCollision && rightCollision < topCollision && rightCollision < bottomCollision ) {\n      this.position[0] = objectRight\n    }\n  };\n\n  attackedObject(object) {\n    let swordHit = this.hurtbox()\n    let objectHit = object.hitbox()\n    if ( this.attacking &&\n      swordHit.x < objectHit.x + objectHit.width &&\n      swordHit.x + swordHit.width > objectHit.x &&\n      swordHit.y < objectHit.y + objectHit.height &&\n      swordHit.y + swordHit.height > objectHit.y\n      ) {\n        this.enemyHitSound.play();\n        return true\n      } else {\n        return false\n    }\n  }\n\n  recoil(attackedSide) {\n    if (attackedSide === 0) {\n      this.position = [this.position[0] + 70, this.position[1]]\n    } else if (attackedSide === 1) {\n      this.position = [this.position[0] - 70, this.position[1]]\n    } else if (attackedSide === 2) {\n      this.position = [this.position[0], this.position[1] + 70]\n    } else {\n      this.position = [this.position[0], this.position[1] - 70]\n    }\n  }\n\n  damaged() {\n    this.walking = false;\n    this.stunned = true;\n    this.invincible = true;\n    this.linkHurtSound.play();\n    // this.link.recoil();\n    this.life -= 1;\n    setTimeout(() => {this.stunned = false;}, 500) //stunned after hit\n    setTimeout(() => {this.invincible = false;}, 2000) //invincible for short time after getting hit\n  }\n\n  invincibility() {\n    if (this.invincible) {\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n      this.invFrameCount++\n      if (this.invFrameCount < 5) {\n        return;\n      }\n      this.invFrameCount = 0;\n\n      if (this.attacking) {\n        this.swing();\n      } else if (this.walking) {\n        this.step();\n      } else if (this.firingBow) {\n        this.fireBow();\n      } else {\n        this.drawStand();\n      }\n    }\n  }\n\n  //moving\n\n  drawWalkFrame(direction, frame) {\n    this.ctx.drawImage(\n      this.link,\n      WALK_X[direction][frame],\n      WALK_Y[direction],\n      this.width,\n      this.height,\n      this.position[0],\n      this.position[1],\n      this.scaledWidth,\n      this.scaledHeight,\n    )\n    // this.ctx.beginPath();\n    // this.ctx.rect(this.position[0], this.position[1], this.scaledWidth, this.scaledHeight)\n    // this.ctx.lineWidth = 1\n    // this.ctx.strokeStyle = 'yellow';\n    // this.ctx.stroke();\n  };\n\n  step() {\n    if (this.walking) {\n      let numFrames = WALK_X[directions[this.currentDirection]].length\n      let cycleLoop = Array.from({length: numFrames}, (x,i) => i);\n\n      if (this.frameCount < 3) {\n        this.drawWalkFrame(\n          directions[this.currentDirection],\n          cycleLoop[this.currentLoopIndex],\n        );\n        this.frameCount++\n        return\n      }\n      this.frameCount = 0;\n      this.currentLoopIndex++;\n\n      this.drawWalkFrame(\n        directions[this.currentDirection],\n        cycleLoop[this.currentLoopIndex],\n      );\n      if (this.currentLoopIndex >= cycleLoop.length) {\n        this.currentLoopIndex = 0;\n      }\n    }\n  };\n\n  getMoveKeys(e) {\n    this.keys = (this.keys || []);\n    this.keys[e.keyCode] = true;\n  }\n\n  deleteMoveKeys(e) {\n    this.keys[e.keyCode] = false;\n  }\n\n  move(e) {\n    if (this.stunned || this.attacking) {\n      return\n    }\n    if (this.keys[83]) {\n      this.walking = true\n      this.attacking = false;\n      this.position[1] += 15;\n      this.currentDirection = 2;\n    }\n    if (this.keys[87]) {\n      this.walking = true\n      this.attacking = false;\n      this.position[1] -= 15;\n      this.currentDirection = 3;\n    }\n    if (this.keys[65]) {\n      this.walking = true\n      this.attacking = false;\n      this.position[0] -= 15;\n      this.currentDirection = 1;\n    }\n    if (this.keys[68]) {\n      this.walking = true\n      this.attacking = false;\n      this.position[0] += 15;\n      this.currentDirection = 0;\n    }\n  };\n\n  //attacking\n\n  drawAttackFrame(direction, frame) {\n    let attackPosX = this.position[0] + ATTACK_POS_OFFSET[direction][frame][0]*this.scale;\n    let attackPosY = this.position[1] + ATTACK_POS_OFFSET[direction][frame][1]*this.scale;\n    let attackWidth = ATTACK_WIDTHS[direction][frame]\n    let attackHeight = ATTACK_HEIGHTS[direction][frame];\n\n    this.ctx.drawImage(\n      this.link,\n      ATTACK_X[direction][frame],\n      ATTACK_Y[direction][frame],\n      attackWidth,\n      attackHeight,\n      attackPosX,\n      attackPosY,\n      attackWidth*this.scale,\n      attackHeight*this.scale,\n    )\n    // this.ctx.beginPath();\n    // this.ctx.rect(attackPosX, attackPosY, attackWidth*this.scale, attackHeight*this.scale)\n    // this.ctx.lineWidth = 1\n    // this.ctx.strokeStyle = 'yellow';\n    // this.ctx.stroke();\n  };\n\n  swing() {\n    if (this.attacking) {\n      let numFrames = ATTACK_X[attack_directions[this.currentDirection]].length;\n      let cycleLoop = Array.from({length: numFrames}, (x,i) => i);\n      while (this.attackCurrentLoopIndex <= cycleLoop.length) {\n        if (this.attackFrameCount < 3) {\n          this.drawAttackFrame(\n            attack_directions[this.currentDirection],\n            cycleLoop[this.attackCurrentLoopIndex],\n          );\n          this.attackFrameCount++\n          return;\n        }\n        this.attackFrameCount = 0;\n\n        this.attackCurrentLoopIndex++;\n        if (this.attackCurrentLoopIndex === cycleLoop.length) {\n          break;\n        }\n\n        this.drawAttackFrame(\n          attack_directions[this.currentDirection],\n          cycleLoop[this.attackCurrentLoopIndex],\n        );\n      }\n      this.attackCurrentLoopIndex = 0;\n      this.attacking = false;\n    }\n  }\n\n  attack(e) {\n    if ((this.stunned || this.firingBow || this.attacking)) {\n      return;\n    }\n    if (this.keys[72]) {\n      const swordSoundIdx = Math.floor(Math.random()*2)\n      this.swordSwingSounds[swordSoundIdx].play();\n      this.walking = false;\n      this.attacking = true;\n    }\n  }\n\n  drawBowFrame(frame) {\n    this.ctx.drawImage(\n      this.link2,\n      frame[0],\n      frame[1],\n      frame[2],\n      frame[3],\n      this.position[0],\n      this.position[1],\n      frame[2]*this.scale,\n      frame[3]*this.scale,\n    )\n  }\n\n  fireBow() {\n    if (this.firingBow) {\n      let allFrames = BOW_SPRITES[bow_directions[this.currentDirection]]\n      let numFrames = allFrames.length\n      if (this.bowFrameCount < 8) {\n        this.drawBowFrame(allFrames[this.bowCurrentLoopIndex]),\n        this.bowFrameCount++;\n        return;\n      }\n      this.bowFrameCount = 0;\n      this.bowCurrentLoopIndex++;\n      if (this.bowCurrentLoopIndex >= numFrames) {\n        this.bowCurrentLoopIndex = 0\n        this.firingBow = false;\n        return\n      }\n      this.drawBowFrame(allFrames[this.bowCurrentLoopIndex]);\n    }\n  }\n\n  useBow(e) {\n    if ((this.stunned || this.firingBow || this.attacking)) {\n      return;\n    }\n    if (this.keys[66] && this.ammo > 0) {\n      this.arrowShootSound.play();\n      this.firingBow = true;\n    }\n  }\n\n  drawStand() {\n    this.ctx.drawImage(\n      this.link,\n      STANDING[this.currentDirection][0],\n      STANDING[this.currentDirection][1],\n      this.width,\n      this.height,\n      this.position[0],\n      this.position[1],\n      this.scaledWidth,\n      this.scaledHeight,\n    );\n  }\n\n  stand() {\n    if ((this.walking || this.attacking || this.firingBow) === false) {\n      this.drawStand();\n    }\n  }\n\n  pickUpItem(item) {\n    this.getItemSound.play();\n    if (item instanceof ArrowItem) {\n      this.ammo += item.value;\n    } else if (item instanceof HeartItem && this.life <= 6) {\n      this.life++;\n    }\n  }\n\n  preventOffscreen() {\n    if (this.position[0] < 0) {\n      this.position[0] = 0\n    }\n    if (this.position[0] + this.scaledWidth > this.canvas.width) {\n      this.position[0] = this.canvas.width - this.scaledWidth\n    }\n    if (this.position[1] < 0) {\n      this.position[1] = 0\n    }\n    if (this.position[1] + this.scaledHeight > this.canvas.height) {\n      this.position[1] = this.canvas.height - this.scaledHeight\n    }\n  }\n\n  stopWalking(e) {\n    this.walking = false;\n  }\n\n  draw() {\n    this.preventOffscreen();\n    this.swing();\n    this.step();\n    this.fireBow();\n    this.stand();\n    this.invincibility();\n  };\n}\n\nexport default Link;\n","import Enemy from './enemy';\n\nconst moblin_directions = [\"walkRight\", \"walkLeft\", \"walkDown\", \"walkUp\"];\n\nconst MOBLIN_SPRITES = {\n  \"walkRight\": [\n    [160, 0, 24, 26],\n    [160, 40, 24, 26],\n    // [160, 80, 24, 26],\n  ],\n  \"walkLeft\": [\n    [222, 14, 24, 26],\n    [222, 54, 24, 26],\n    // [222, 94, 24, 26],\n  ],\n  \"walkDown\": [\n    [124, 0, 17, 32],\n    [124, 38, 17, 32],\n    // [123, 81, 17, 32],\n  ],\n  \"walkUp\": [\n    [203, 0, 18, 28],\n    [203, 40, 18, 28],\n    // [203, 80, 18, 30],\n  ],\n};\n\nclass Moblin extends Enemy {\n  constructor(canvas, ctx, pos) {\n    super(canvas, ctx, pos);\n    this.currentDirection = 2;\n    this.moblin = new Image();\n    this.moblin.src = './assets/enemies.png';\n    this.currentLoopIndex = 0;\n    this.frameCount = 0;\n    this.width = 24;\n    this.height = 26;\n    this.life = 3;\n    this.scale = 2.6;\n    this.speed = .5 + Math.random();\n    this.scaledWidth = this.width*this.scale;\n    this.scaledHeight = this.height*this.scale;\n  }\n\n  hitbox() {\n    return {\n      x: this.position[0],\n      y: this.position[1],\n      width: this.scaledWidth,\n      height: this.scaledHeight,\n    }\n  };\n\n  move(player) {\n    this.moveTowardsObject(player)\n  }\n\n  step() {\n    if (this.poofing) {\n      return\n    }\n    let allFrames = MOBLIN_SPRITES[moblin_directions[this.currentDirection]]\n    let numFrames = allFrames.length;\n    if (this.frameCount < 8) {\n      this.drawWalkFrame(allFrames[this.currentLoopIndex])\n      this.frameCount++;\n      return\n    }\n    this.frameCount = 0;\n    this.currentLoopIndex++;\n    if (this.currentLoopIndex >= numFrames) {\n      this.currentLoopIndex = 0;\n    }\n    this.drawWalkFrame(allFrames[this.currentLoopIndex])\n  }\n\n  drawWalkFrame(frame) {\n    this.ctx.drawImage(\n      this.moblin,\n      frame[0],\n      frame[1],\n      frame[2],\n      frame[3],\n      this.position[0],\n      this.position[1],\n      this.scale*frame[2],\n      this.scale*frame[3],\n    )\n    // this.ctx.beginPath();\n    // this.ctx.rect(this.position[0], this.position[1], this.scaledWidth, this.scaledHeight)\n    // this.ctx.lineWidth = 1\n    // this.ctx.strokeStyle = 'yellow';\n    // this.ctx.stroke();\n  }\n\n  draw() {\n    this.step();\n    this.poof();\n  }\n}\n\nexport default Moblin;\n","class Obstacle {\n  constructor(pos, width, height) {\n    this.position = pos;\n    this.width = width;\n    this.height = height;\n    this.scale = 2;\n  }\n\n  hitbox() {\n    return {\n      x: this.position[0]*this.scale,\n      y: this.position[1]*this.scale,\n      width: this.width*this.scale,\n      height: this.height*this.scale,\n    }\n  };\n}\n\nexport default Obstacle;\n","import Game from './game.js';\nimport Info from './info.js';\n\ndocument.addEventListener('DOMContentLoaded', ()=> {\n  const mainCanvas = document.getElementsByClassName('game-canvas')[0];\n  const infoCanvas = document.getElementsByClassName('info-canvas')[0];\n  const ctx = mainCanvas.getContext('2d');\n  const ctxInfo = infoCanvas.getContext('2d');\n\n\n  const game = new Game(mainCanvas, ctx);\n  const info = new Info(infoCanvas, ctxInfo, game)\n  game.openMenu();\n  info.loop();\n});\n","import Enemy from './enemy';\n\nconst WALLMASTER_SPRITES = [\n  [280, 883, 24, 22],\n  [318, 883, 24, 22]\n]\n\nclass Wallmaster extends Enemy {\n  constructor(canvas, ctx, pos) {\n    super(canvas, ctx, pos);\n    this.currentDirection = 0;\n    this.wallmaster = new Image();\n    this.wallmaster.src = './assets/enemies.png';\n    this.currentLoopIndex = 0;\n    this.walkCycle = 0;\n    this.frameCount = -1;\n    this.life = 3;\n    this.scale = 2.6;\n    this.speed = Math.random()*.8;\n\n    this.move = this.move.bind(this);\n  }\n\n  hitbox() {\n    return {\n      x: this.position[0],\n      y: this.position[1],\n      width: 24*this.scale,\n      height: 22*this.scale,\n    }\n  };\n\n  moveTowardsObject(object) {\n    if (object.position[0] < this.position[0]) {\n      this.position[0] -= this.speed;\n      this.currentDirection = 1;\n    }\n    if (object.position[1] < this.position[1]) {\n      this.position[1] -= this.speed;\n      this.currentDirection = 2;\n    }\n    if (object.position[0] > this.position[0]) {\n      this.position[0] += this.speed;\n      this.currentDirection = 0;\n    }\n    if (object.position[1] > this.position[1]) {\n      this.position[1] += this.speed;\n      this.currentDirection = 3;\n    }\n  }\n\n  move(player) {\n    // if (this.currentDirection === 0) {\n    //   this.position[0] += this.speed;\n    //   if (this.position[0] + this.width > this.canvas.width || this.position[0] < 0) {\n    //     this.currentDirection = 1\n    //   }\n    // } else if (this.currentDirection === 1) {\n    //   this.position[0] -= this.speed;\n    //   if (this.position[0] + this.width > this.canvas.width || this.position[0] < 0) {\n    //     this.currentDirection = 0\n    //   }\n    // }\n    this.moveTowardsObject(player)\n  }\n\n  getSprite() {\n    if (this.walkCycle === 0) {\n      return WALLMASTER_SPRITES[0]\n    } else {\n      return WALLMASTER_SPRITES[1]\n    }\n  }\n\n  draw() {\n    if (this.frameCount < 9) {\n      this.frameCount++\n    } else {\n      this.walkCycle = (this.walkCycle === 1 ? 0 : 1)\n      this.frameCount = 0;\n    }\n\n    let sprite = this.getSprite();\n\n    this.ctx.drawImage(\n      this.wallmaster,\n      sprite[0],\n      sprite[1],\n      sprite[2],\n      sprite[3],\n      this.position[0],\n      this.position[1],\n      this.scale*sprite[2],\n      this.scale*sprite[3],\n    )\n  }\n}\n\nexport default Wallmaster;\n"],"sourceRoot":""}