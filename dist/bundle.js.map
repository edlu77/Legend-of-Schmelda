{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./lib/arrow.js","webpack:///./lib/arrow_item.js","webpack:///./lib/enemy.js","webpack:///./lib/game.js","webpack:///./lib/heart_item.js","webpack:///./lib/info.js","webpack:///./lib/item.js","webpack:///./lib/level.js","webpack:///./lib/link.js","webpack:///./lib/moblin.js","webpack:///./lib/obstacle.js","webpack:///./lib/schmelda.js","webpack:///./lib/wallmaster.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEe,oEAAK,EAAC;;;;;;;;;;;;;ACtFrB;AAAA;AAA0B;;AAE1B;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,6CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEe,wEAAS,EAAC;;;;;;;;;;;;;ACxDzB;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB,sBAAsB;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEe,oEAAK,EAAC;;;;;;;;;;;;;ACrLrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyC;AACR;AACJ;AACE;AACS;AACA;AACH;AACR;AACC;;AAE9B;AACA;AACA;AACA;AACA,oBAAoB,gDAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gDAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,2BAA2B;AAC9C,qBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,kDAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,sDAAS;AACnC,KAAK;AACL;AACA,0BAA0B,sDAAS;AACnC,KAAK;AACL;AACA;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;;AAEA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;;AAEA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,6BAA6B,iDAAK;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,2BAA2B;AAC9C,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,iDAAK;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B,8BAA8B,sDAAU;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEe,mEAAI,EAAC;;;;;;;;;;;;;ACvcpB;AAAA;AAA0B;;AAE1B,wBAAwB,6CAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEe,wEAAS,EAAC;;;;;;;;;;;;;AC7CzB;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEe,mEAAI,EAAC;;;;;;;;;;;;;AClEpB;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,sBAAsB;AAC5C;;AAEA;;AAEe,mEAAI,EAAC;;;;;;;;;;;;;ACfpB;AAAA;AAAA;AAAA;AAAqC;AACJ;AACQ;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,oDAAQ;AACtC,KAAK;AACL;AACA;;AAEA;;AAEe,oEAAK;;;;;;;;;;;;;ACxCpB;AAAA;AAAA;AAAqC;AACG;;AAExC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C,sBAAsB,yBAAyB;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,mDAAS;AACjC;AACA,KAAK,0BAA0B,sDAAS;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,mEAAI,EAAC;;;;;;;;;;;;;AC7vBpB;AAAA;AAA4B;;AAE5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,8CAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,qEAAM,EAAC;;;;;;;;;;;;;AC7GtB;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,uEAAQ,EAAC;;;;;;;;;;;;;AClBxB;AAAA;AAAA;AAA6B;AACA;;AAE7B;AACA;AACA;AACA;AACA;;;AAGA,mBAAmB,gDAAI;AACvB,mBAAmB,gDAAI;AACvB;AACA;AACA,CAAC;;;;;;;;;;;;;ACdD;AAAA;AAA4B;;AAE5B;AACA;AACA;AACA;;AAEA,yBAAyB,8CAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,yEAAU,EAAC","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./lib/schmelda.js\");\n","const ARROW_SPRITES = [\n  [295, 376, 15, 5],\n  [194, 354, 15, 5],\n  [401, 104, 5, 15],\n  [395, 344, 5, 15],\n]\n\nclass Arrow {\n  constructor(canvas, ctx, pos, direction) {\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.position = pos;\n    this.scale = 1.5;\n    this.arrow = new Image();\n    this.arrow.src = './assets/link-2.gif';\n    this.direction = direction;\n    this.width = (this.direction === 0 || this.direction === 1) ? 15 : 5;\n    this.height = (this.direction === 1 || this.direction === 0) ? 5 : 15;\n\n    this.move = this.move.bind(this);\n  }\n\n  hitbox() {\n    return {\n      x: this.position[0],\n      y: this.position[1],\n      width: this.width,\n      height: this.height,\n    }\n  };\n\n  collidedWith(object) {\n    let enemyHit = this.hitbox()\n    let objectHit = object.hitbox()\n    if (enemyHit.x < objectHit.x + objectHit.width && enemyHit.x + enemyHit.width > objectHit.x\n        && enemyHit.y < objectHit.y + objectHit.height && enemyHit.y + enemyHit.height > objectHit.y) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  getSprite() {\n    return ARROW_SPRITES[this.direction]\n  }\n\n  move() {\n    if (this.direction === 0) {\n      this.position[0] += 5;\n    } else if (this.direction === 1) {\n      this.position[0] -= 5;\n    } else if (this.direction === 2) {\n      this.position[1] += 5;\n    } else {\n      this.position[1] -= 5;\n    }\n  }\n\n  draw() {\n    let sprite = this.getSprite();\n    this.ctx.drawImage(\n      this.arrow,\n      sprite[0],\n      sprite[1],\n      sprite[2],\n      sprite[3],\n      this.position[0],\n      this.position[1],\n      this.scale*sprite[2],\n      this.scale*sprite[3],\n    )\n  }\n\n  isOffscreen() {\n    if (\n      this.position[0] > this.canvas.width ||\n      this.position[0] + this.width < 0 ||\n      this.position[1] + this.height < 0 ||\n      this.position[1] > this.canvas.height) {\n      return true\n    } else {\n      return false\n    }\n  }\n}\n\nexport default Arrow;\n","import Item from './item';\n\nconst ARROW_ITEM_SPRITES = {\n  1: [192, 8, 16, 16],\n  5: [235, 8, 16, 16],\n  10: [259, 8, 16, 16],\n}\n\nclass ArrowItem extends Item {\n  constructor(canvas, ctx, pos, value) {\n    super(canvas, ctx, pos);\n    this.arrowItem = new Image();\n    this.arrowItem.src = './assets/items-overworld.png';\n    this.value = value;\n    this.width = 16;\n    this.height = 16;\n    this.weight = 10;\n  }\n\n  hitbox() {\n    return {\n      x: this.position[0],\n      y: this.position[1],\n      width: this.width*this.scale,\n      height: this.height*this.scale,\n    }\n  };\n\n  getSprite(){\n    return ARROW_ITEM_SPRITES[this.value]\n  }\n\n  draw() {\n    if (this.flashing) {\n      this.flashFrameCount++\n      if (this.flashFrameCount < 5) {\n        return;\n      }\n      this.flashFrameCount = 0;\n    }\n    const sprite = this.getSprite();\n    this.ctx.drawImage(\n      this.arrowItem,\n      sprite[0],\n      sprite[1],\n      sprite[2],\n      sprite[3],\n      this.position[0],\n      this.position[1],\n      this.scale*sprite[2],\n      this.scale*sprite[3],\n    )\n  }\n\n}\n\nexport default ArrowItem;\n","const DEATH_POOF = [\n  [79, 4, 24, 24],\n  [105, 4, 24, 24],\n  [131, 3, 24, 24],\n  [157, 4, 24, 24]\n]\n\nclass Enemy {\n  constructor(canvas, ctx, pos) {\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.position = pos;\n    this.scale = 2.6;\n    this.enemyDeathSound = new Audio('./assets/LTTP_Enemy_Kill.wav')\n    this.poofCurrentLoopIndex = 0;\n    this.poofFrameCount = 0;\n    this.deathPoof = new Image;\n    this.deathPoof.src = './assets/death-effects.png';\n    this.dead = false;\n    this.poofing = false;\n    this.flashing = false;\n    this.stunned = false;\n  }\n\n  recoil(attackedSide) {\n    if (attackedSide === 0) {\n      this.position = [this.position[0] + 40, this.position[1]]\n    } else if (attackedSide === 1) {\n      this.position = [this.position[0] - 40, this.position[1]]\n    } else if (attackedSide === 2) {\n      this.position = [this.position[0], this.position[1] + 40]\n    } else {\n      this.position = [this.position[0], this.position[1] - 40]\n    }\n  };\n\n  damaged(attack) {\n    this.flashing = true;\n    this.stunned = true;\n    this.life -= attack;\n    setTimeout(() => {this.flashing = false; this.stunned = false}, 2000)\n  }\n\n  drawDeathPoof(frame) {\n    this.ctx.drawImage(\n      this.deathPoof,\n      frame[0],\n      frame[1],\n      frame[2],\n      frame[3],\n      this.position[0],\n      this.position[1],\n      frame[2]*this.scale,\n      frame[3]*this.scale,\n    )\n  }\n\n  poof() {\n    if (this.poofing) {\n      this.flashing = false;\n      let currentFrame = DEATH_POOF[this.poofCurrentLoopIndex]\n      let numFrames = 4;\n      if (this.poofFrameCount < 5) {\n        this.drawDeathPoof(currentFrame),\n        this.poofFrameCount++;\n        return;\n      }\n      this.poofFrameCount = 0;\n      this.poofCurrentLoopIndex++;\n      if (this.poofCurrentLoopIndex >= numFrames) {\n        this.poofing = false;\n        this.poofCurrentLoopIndex = 0\n        return\n      }\n      this.drawDeathPoof(currentFrame)\n    }\n  }\n\n\n  isFullyDestroyed() {\n    if (this.poofing) {\n      return false;\n    } else if (this.dead) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  collidedWith(object) {\n    let enemyHit = this.hitbox()\n    let objectHit = object.hitbox()\n    if (enemyHit.x < objectHit.x + objectHit.width && enemyHit.x + enemyHit.width > objectHit.x\n        && enemyHit.y < objectHit.y + objectHit.height && enemyHit.y + enemyHit.height > objectHit.y) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  moveTowardsObject(object) {\n    if (this.poofing || this.stunned) {\n      return\n    }\n    let dx = Math.abs(object.position[0] - this.position[0]);\n    let dy = Math.abs(object.position[1] - this.position[1]);\n\n    if (object.position[0] < this.position[0]) {\n      this.position[0] -= this.speed;\n      if (dx > dy) {\n        this.currentDirection = 1;\n      }\n    }\n    if (object.position[1] < this.position[1]) {\n      this.position[1] -= this.speed;\n      if (dy > dx) {\n        this.currentDirection = 3;\n      }\n    }\n    if (object.position[0] > this.position[0]) {\n      this.position[0] += this.speed;\n      if (dx > dy) {\n        this.currentDirection = 0;\n      }\n    }\n    if (object.position[1] > this.position[1]) {\n      this.position[1] += this.speed;\n      if (dy > dx) {\n        this.currentDirection = 2;\n      }\n    }\n  }\n\n  moveAwayFromEnemy(enemy) {\n    if (this.poofing || this.stunned) {\n      return\n    }\n    if (enemy.position[0] < this.position[0]) {\n      this.position[0] += 1;\n    }\n    if (enemy.position[1] < this.position[1]) {\n      this.position[1] += 1;\n    }\n    if (enemy.position[0] > this.position[0]) {\n      this.position[0] -= 1;\n    }\n    if (enemy.position[1] > this.position[1]) {\n      this.position[1] -= 1;\n    }\n  }\n\n  moveAwayFromObject(object) {\n    const enemyHit = this.hitbox()\n    const objectHit = object.hitbox()\n\n    const linkBottom = enemyHit.y + enemyHit.height;\n    const objectBottom = objectHit.y + objectHit.height;\n    const linkRight = enemyHit.x + enemyHit.width;\n    const objectRight = objectHit.x + objectHit.width;\n\n    const bottomCollision = objectBottom - enemyHit.y;\n    const topCollision = linkBottom - objectHit.y;\n    const leftCollision = linkRight - objectHit.x;\n    const rightCollision = objectRight - enemyHit.x;\n\n    if (topCollision < bottomCollision && topCollision < leftCollision && topCollision < rightCollision ) {\n      this.position[1] = objectHit.y - enemyHit.height\n    }\n    if (bottomCollision < topCollision && bottomCollision < leftCollision && bottomCollision < rightCollision) {\n      this.position[1] = objectBottom\n    }\n    if (leftCollision < rightCollision && leftCollision < topCollision && leftCollision < bottomCollision) {\n      this.position[0] = objectHit.x - enemyHit.width\n    }\n    if (rightCollision < leftCollision && rightCollision < topCollision && rightCollision < bottomCollision ) {\n      this.position[0] = objectRight\n    }\n  };\n\n};\n\nexport default Enemy;\n","import Wallmaster from './wallmaster.js';\nimport Moblin from './moblin.js';\nimport Link from './link.js';\nimport Arrow from './arrow.js';\nimport ArrowItem from './arrow_item.js';\nimport HeartItem from './heart_item.js';\nimport Obstacle from './obstacle.js';\nimport Info from './info.js';\nimport Level from './level.js'\n\nclass Game {\n  constructor(canvas, ctx) {\n    this.enemies = [];\n    this.obstacles = [];\n    this.link = new Link(canvas, ctx);\n    this.ctx = ctx;\n    this.canvas = canvas;\n    this.arrows = [];\n    this.items = [];\n    this.oldTime = Date.now();\n    this.oldArrowTime = Date.now();\n    this.isGameOver = false;\n    this.score = 0;\n    this.canRestart = false;\n    this.currentMusic = null;\n    this.musicMuted = false;\n    this.currentLevel = 1;\n    this.nextLevelOpen = false;\n\n    this.mainMenuTheme = new Audio('./assets/Name_Entry.mp3');\n    this.hyruleTheme = new Audio('./assets/Hyrule_Field.mp3');\n    this.gameOverTheme = new Audio('./assets/Kakariko_Village.mp3');\n    this.arrowHitSound = new Audio('./assets/LTTP_Arrow_Hit.wav');\n    this.startGameSound = new Audio('./assets/LTTP_Secret.wav');\n    this.dungeonTheme = new Audio('./assets/Dungeon_Theme_02.mp3');\n\n    this.draw = this.draw.bind(this);\n    this.loop = this.loop.bind(this);\n    this.makeEnemy = this.makeEnemy.bind(this);\n    this.makeArrow = this.makeArrow.bind(this);\n    this.startGame = this.startGame.bind(this);\n    this.playTheme = this.playTheme.bind(this);\n    this.restartGame = this.restartGame.bind(this);\n    this.muteMusic = this.muteMusic.bind(this);\n    this.onMusic = this.onMusic.bind(this);\n    this.makeLevel = this.makeLevel.bind(this);\n  }\n\n  openMenu() {\n    const musicOffButton = document.getElementsByClassName('music-button off')[0];\n    const musicOnButton = document.getElementsByClassName('music-button on')[0];\n    if (this.musicMuted) {\n      musicOffButton.className = 'music-button off hidden';\n      musicOnButton.className = 'music-button on';\n    } else {\n      musicOffButton.className = 'music-button off';\n      musicOnButton.className = 'music-button on hidden';\n    }\n    this.currentMusic = this.mainMenuTheme;\n    this.playTheme();\n    document.addEventListener('click', this.muteMusic);\n    document.addEventListener('click', this.onMusic);\n    this.setStartButton();\n  }\n\n  setStartButton() {\n    const startGameButton = document.getElementsByClassName('start-game-button')[0]\n    startGameButton.addEventListener('click', (e) => {\n      this.startGameSound.play();\n      this.currentMusic.pause();\n      this.openGameWindow();\n      setTimeout(this.startGame, 800);\n    });\n  }\n\n  openGameWindow() {\n    const mainMenu = document.getElementsByClassName('main-menu')[0];\n    mainMenu.className = 'main-menu close';\n    const gameOver = document.getElementsByClassName('game-over')[0];\n    gameOver.className = 'game-over close';\n    const gameWindow = document.getElementsByClassName('game-window')[0];\n    gameWindow.className = 'game-window';\n  }\n\n  playTheme() {\n    if (!this.musicMuted) {\n      this.currentMusic.play();\n    }\n  }\n\n  startGame() {\n    this.isGameOver = false;\n    this.canRestart = false;\n    this.arrows = [];\n    this.items = [];\n    this.enemies = [];\n    this.score = 0;\n    this.oldTime = Date.now();\n    this.link = new Link(this.canvas, this.ctx);\n    this.currentMusic = this.hyruleTheme;\n    this.currentLevel = 1;\n    this.nextLevelOpen = false;\n    setTimeout(this.playTheme, 1000);\n    this.combineListeners();\n    this.loop();\n  }\n\n  stopGame() {\n    this.enemies = [];\n    const gameWindow = document.getElementsByClassName('game-window')[0] ? document.getElementsByClassName('game-window')[0] : document.getElementsByClassName('game-window-2')[0];\n    gameWindow.className = 'game-window close';\n  }\n\n  gameOver() {\n    if (this.isGameOver) {\n      this.canRestart = true;\n      this.stopGame();\n      const gameOver = document.getElementsByClassName('game-over')[0];\n      gameOver.className = 'game-over';\n      this.currentMusic.pause();\n      this.currentMusic = this.gameOverTheme;\n      this.playTheme();\n    }\n  }\n\n  restartGame(e) {\n    if (this.canRestart) {\n      const restartButton = document.getElementsByClassName('restart-button')[0]\n      if (e.target === restartButton) {\n        this.startGameSound.play();\n        this.currentMusic.pause();\n        this.openGameWindow();\n        setTimeout(this.startGame, 800);\n      }\n    }\n  }\n\n  muteMusic(e) {\n    const musicOffButton = document.getElementsByClassName('music-button off')[0];\n    const musicOnButton = document.getElementsByClassName('music-button on')[0];\n    if (!this.musicMuted) {\n      if (e.target === musicOffButton) {\n        this.currentMusic.pause();\n        this.musicMuted = true;\n        musicOffButton.className = 'music-button off hidden';\n        musicOnButton.className = 'music-button on';\n      }\n    }\n  }\n\n  onMusic(e) {\n    const musicOnButton = document.getElementsByClassName('music-button on')[0];\n    const musicOffButton = document.getElementsByClassName('music-button off')[0];\n    if (this.musicMuted) {\n      if (e.target === musicOnButton) {\n        this.currentMusic.play();\n        this.musicMuted = false;\n        musicOnButton.className = 'music-button on hidden';\n        musicOffButton.className = 'music-button off';\n      }\n    }\n  }\n\n  combineListeners() {\n    document.addEventListener('keydown', this.link.getMoveKeys);\n    document.addEventListener('keyup', this.link.deleteMoveKeys);\n    document.addEventListener('keyup', this.link.stopWalking);\n    document.addEventListener('keydown', this.link.attack);\n    document.addEventListener('keydown', this.link.useBow);\n    // document.addEventListener('keydown', this.link.spin); //enable spinning\n    document.addEventListener('click', this.restartGame);\n\n  }\n\n\n\n  loop() {\n    if (!this.isGameOver) {\n      this.update();\n      this.draw();\n      window.requestAnimationFrame(this.loop)\n    }\n  }\n\n  update() {\n    this.link.move();\n    this.handleObstacleCollisions();\n    this.makeEnemy();\n    this.updateEnemies();\n    this.avoidOverlap();\n    this.updateArrows();\n    this.makeArrow();\n    this.updateItems();\n    this.gameOver();\n    this.makeLevel();\n    this.openNextLevel();\n    this.moveToNextLevel();\n  }\n\n  draw() {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n    this.link.draw();\n    this.drawEnemies();\n    this.drawArrows();\n    this.drawItems();\n    // this.drawObstacles();\n  }\n\n\n  drawObstacles() {\n    for (var i = 0; i < this.obstacles.length; i++) {\n      this.ctx.beginPath();\n      this.ctx.rect(this.obstacles[i].hitbox().x, this.obstacles[i].hitbox().y, this.obstacles[i].hitbox().width, this.obstacles[i].hitbox().height)\n      this.ctx.lineWidth = 1\n      this.ctx.strokeStyle = 'yellow';\n      this.ctx.stroke();\n    }\n  }\n\n  handleObstacleCollisions() {\n    for (let i = 0; i < this.obstacles.length; i++) {\n      for (let j = 0; j < this.enemies.length; j++) {\n        if (this.enemies[j].collidedWith(this.obstacles[i])) {\n          this.enemies[j].moveAwayFromObject(this.obstacles[i]);\n        }\n      }\n      if (this.link.collidedWith(this.obstacles[i])) {\n        this.link.moveAwayFromObject(this.obstacles[i])\n      }\n    }\n  }\n\n  makeEnemy() {\n    if (Date.now() - this.oldTime > 2000 && this.enemies.length < 6 && !this.isGameOver && this.currentLevel === 1) {\n      this.enemies.push(new Moblin(this.canvas, this.ctx, this.enemySpawnPos()));\n      this.oldTime = Date.now();\n    }\n    //\n    // if (Date.now() - this.oldTime > 2000 && this.enemies.length < 6 && !this.isGameOver && this.currentLevel === 2) {\n    //   this.enemies.push(new Wallmaster(this.canvas, this.ctx, this.enemySpawnPos()));\n    //   this.oldTime = Date.now();\n    // }\n  }\n\n  dropItem(position) {\n    const roll = Math.random()*10;\n    if (roll < 1) {\n      this.items.push(new HeartItem(this.canvas, this.ctx, position, 1))\n    } else if (roll >= 1 && roll < 3) {\n      const amount = [1, 5, 10][Math.floor(Math.random()*3)]\n      this.items.push(new ArrowItem(this.canvas, this.ctx, position, amount))\n    } else {\n      return\n    }\n  }\n\n  updateEnemies() {\n    for (let i = 0; i < this.enemies.length; i++) {\n      this.handleDestroyed(this.enemies[i], i);\n      if (this.enemies[i]) {\n        this.enemies[i].move(this.link);\n        this.checkDealtDamage(this.enemies[i]);\n        this.checkAttacked(this.enemies[i]);\n        this.checkArrowHits(this.enemies[i]);\n      }\n    }\n  }\n\n  handleDestroyed(enemy, idx) {\n    if (enemy.isFullyDestroyed()) {\n      this.dropItem(\n        [enemy.position[0] + (enemy.scaledWidth/2),\n          enemy.position[1] + (enemy.scaledHeight/2)]\n      )\n      this.enemies.splice(idx, 1);\n      this.score++;\n    }\n  }\n\n  checkDealtDamage(enemy) {\n    if (this.link.collidedWith(enemy) && this.link.invincible === false && enemy.poofing === false) {\n      this.link.damaged();\n      if (this.link.life === 0) {\n        this.isGameOver = true;\n      }\n    }\n  }\n\n  checkAttacked(enemy) {\n    if (this.link.attackedObject(enemy)) {\n      if (enemy.life - this.link.attackValue <= 0) {\n        enemy.enemyDeathSound.play();\n        enemy.dead = true;\n        enemy.poofing = true;\n      } else {\n        enemy.damaged(this.link.attackValue);\n        enemy.recoil(this.link.attackDirection);\n      }\n    }\n  }\n\n  checkArrowHits(enemy) {\n    for (let j = 0; j < this.arrows.length; j++) {\n      if (enemy.collidedWith(this.arrows[j])) {\n        this.arrowHitSound.play();\n        if (enemy.life <= 0) {\n          enemy.enemyDeathSound.play();\n          enemy.dead = true;\n          enemy.poofing = true;\n        } else {\n          enemy.damaged(this.link.attackValue);\n          enemy.recoil(this.arrows[j].direction);\n        }\n        this.arrows.splice(j, 1);\n      }\n    }\n  }\n\n  drawEnemies() {\n    for (let i = 0; i < this.enemies.length; i++) {\n      this.enemies[i].draw();\n    }\n  }\n\n  drawItems() {\n    for (let i = 0; i < this.items.length; i++) {\n      this.items[i].draw();\n    }\n  }\n\n  updateItems() {\n    for (let i = 0; i < this.items.length; i++) {\n      if (Date.now() - this.items[i].spawnTime > 10000) {\n        this.items.splice(i, 1);\n      }\n\n      if (this.items[i]) {\n        if (this.link.collidedWith(this.items[i])) {\n          this.link.pickUpItem(this.items[i]);\n          this.items.splice(i, 1);\n        }\n      }\n    }\n  }\n\n  makeArrow() {\n    if (this.link.firingBow) {\n      let startPos = this.link.position.slice(0);\n      if (this.link.currentDirection === 0) {\n        startPos[0] += this.link.scaledWidth;\n        startPos[1] += this.link.scaledHeight/2;\n      } else if (this.link.currentDirection === 1) {\n        startPos[0] -= 20;\n        startPos[1] = startPos[1] + this.link.scaledHeight/2;\n      } else if (this.link.currentDirection === 2) {\n        startPos[0] += this.link.scaledWidth/2;\n        startPos[1] += this.link.scaledHeight;\n      } else {\n        startPos[0] += this.link.scaledWidth/2;\n        startPos[1] -= 20;\n      }\n\n      if (this.arrowLimit()) {\n        return\n      } else {\n        this.link.arrowShootSound.play();\n        this.arrows.push(new Arrow(this.canvas, this.ctx, startPos, this.link.currentDirection));\n        this.link.ammo -= 1;\n      }\n    }\n  }\n\n  arrowLimit() {\n    if (Date.now() - this.oldArrowTime < 500) {\n      return true\n    }\n    this.oldArrowTime = Date.now();\n  }\n\n  updateArrows() {\n    for (let i = 0; i < this.arrows.length; i++) {\n      if (this.arrows[i].isOffscreen()) {\n        this.arrows.splice(i, 1);\n      }\n      if (this.arrows[i]) {\n        this.arrows[i].move();\n      }\n    }\n  }\n\n  drawArrows() {\n    for (let i = 0; i < this.arrows.length; i++) {\n      this.arrows[i].draw();\n    }\n  }\n\n  enemySpawnPos() {\n    const spawnPoint = Math.floor(Math.random()*5);\n    switch (spawnPoint) {\n      case 0:\n        return [-50, (104 + Math.random()*21)*2] //left side\n      case 1:\n        return [this.canvas.width+50, (110 + Math.random()*20)*2] //right side\n      case 2:\n        return [(96 + Math.random()*63)*2, this.canvas.height+ 50] //bottom side\n      case 3:\n        return [111*2, 13*2] //left log\n      case 4:\n        return [223*2, 13*2] //right log\n    }\n  }\n\n  avoidOverlap() {\n    for (let i = 0; i < this.enemies.length-1; i++) {\n      for (let j = i+1; j < this.enemies.length; j++) {\n        if (this.enemies[i].collidedWith(this.enemies[j])) {\n          this.enemies[i].moveAwayFromEnemy(this.enemies[j])\n          this.enemies[j].moveAwayFromEnemy(this.enemies[i])\n        }\n      }\n    }\n  }\n\n  makeLevel() {\n    let currentLevel = new Level(this.currentLevel);\n    this.obstacles = currentLevel.makeObstacles();\n  }\n\n  openNextLevel() {\n    if (this.score >= 3 && this.nextLevelOpen === false) {\n      this.startGameSound.play();\n      this.nextLevelOpen = true;\n    }\n  }\n\n  moveToNextLevel() {\n    const gameWindow = document.getElementsByClassName('game-window')[0];\n    if (this.link.position[1] + this.link.scaledHeight > this.canvas.height && this.currentLevel === 1 && this.nextLevelOpen) {\n      gameWindow.className = 'game-window-2';\n      this.currentLevel = 2;\n      this.currentMusic.pause();\n      this.currentMusic = this.dungeonTheme;\n      this.playTheme();\n      this.enemies = [];\n      for (let i = 0; i <= 6; i++) {\n        this.enemies.push(new Wallmaster(this.canvas, this.ctx, [100 + i*60, 300]))\n      }\n      this.items = [];\n      this.arrows = [];\n      this.link.position = [338, 56]\n    }\n  }\n\n}\n\nexport default Game;\n","import Item from './item';\n\nclass HeartItem extends Item {\n  constructor(canvas, ctx, pos, value) {\n    super(canvas, ctx, pos);\n    this.heartItem = new Image();\n    this.heartItem.src = './assets/items-overworld.png';\n    this.width = 14;\n    this.height = 13;\n    this.weight = 10;\n    this.scale = 2\n  }\n\n  hitbox() {\n    return {\n      x: this.position[0],\n      y: this.position[1],\n      width: this.width*this.scale,\n      height: this.height*this.scale,\n    }\n  };\n\n  draw() {\n    if (this.flashing) {\n      this.flashFrameCount++\n      if (this.flashFrameCount < 5) {\n        return;\n      }\n      this.flashFrameCount = 0;\n    }\n    this.ctx.drawImage(\n      this.heartItem,\n      273,\n      58,\n      this.width,\n      this.height,\n      this.position[0],\n      this.position[1],\n      this.width*this.scale,\n      this.height*this.scale,\n    )\n  }\n\n}\n\nexport default HeartItem;\n","class Info {\n  constructor(canvas, ctx, game) {\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.game = game;\n    this.heart = new Image();\n    this.heart.src = './assets/items-overworld.png';\n    this.bow = new Image();\n    this.bow.src = './assets/items-overworld.png';\n\n    this.draw = this.draw.bind(this);\n    this.loop = this.loop.bind(this);\n  }\n\n  draw() {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n    const score = `Score: ${this.game.score}`;\n    this.ctx.font = '40px returnofganon';\n    this.ctx.fillStyle = 'white';\n    this.ctx.textAlign = 'left';\n\n    this.drawHearts();\n    this.drawBow();\n    this.ctx.fillText(score, 10, 120);\n  }\n\n  drawHearts() {\n    const life = this.game.link.life;\n    for (let i = 0; i < life; i++) {\n      this.ctx.drawImage(\n        this.heart,\n        273,\n        58,\n        14,\n        13,\n        10 + i*35,\n        15,\n        28,\n        26,\n      )\n    }\n  }\n\n  drawBow() {\n    const arrows = `: ${this.game.link.ammo}`;\n    this.ctx.drawImage(\n      this.bow,\n      173,\n      9,\n      15,\n      15,\n      10,\n      50,\n      30,\n      30,\n    )\n    this.ctx.fillText(arrows, 45, 79)\n  }\n\n  loop() {\n    this.draw();\n    window.requestAnimationFrame(this.loop);\n  }\n}\n\nexport default Info;\n","class Item {\n  constructor(canvas, ctx, pos) {\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.position = pos;\n    this.scale = 2.6;\n    this.itemGetSound = new Audio('./assets/LTTP_Item.wav');\n    this.spawnTime = Date.now();\n    this.flashing = false;\n\n    setTimeout(() => {this.flashing = true;}, 7000)\n  }\n\n}\n\nexport default Item;\n","import Obstacle from './obstacle.js';\nimport Moblin from './moblin.js';\nimport Wallmaster from './wallmaster.js';\n\nconst OBSTACLES = {\n  1: [\n    [[0, 0], 355, 23],\n    [[0, 32], 25, 72],\n    [[0, 193], 79, 48],\n    [[0, 241], 96, 11],\n    [[329, 29], 26, 72],\n    [[268, 195], 87, 57],\n    [[252, 244], 16, 8],\n  ],\n  2: [\n    [[0, 0], 165, 47],\n    [[189, 0], 166, 47],\n    [[0, 22], 41, 230],\n    [[313, 25], 20, 181],\n    [[313, 22], 42, 230],\n    [[0, 206], 355, 46],\n  ]\n}\n\nclass Level {\n  constructor (currentLevel) {\n    this.level = currentLevel;\n    this.obstacles = [];\n    this.enemies = [];\n  }\n\n  makeObstacles () {\n    OBSTACLES[this.level].forEach ((obstacle) => {\n      this.obstacles.push(new Obstacle(obstacle[0], obstacle[1], obstacle[2]))\n    })\n    return this.obstacles;\n  }\n\n}\n\nexport default Level\n","import ArrowItem from './arrow_item';\nimport HeartItem from './heart_item.js';\n\nconst directions = [\"walkRight\", \"walkLeft\", \"walkDown\", \"walkUp\"];\n\nconst WALK_SPRITES = {\n  \"walkRight\": [\n    [241, 120, 19, 24],\n    [272, 120, 18, 24],\n    [301, 120, 19, 23],\n    [331, 120, 19, 23],\n    [361, 120, 19, 24],\n    [392, 120, 18, 24],\n  ],\n  \"walkLeft\": [\n    [241, 30, 19, 24],\n    [272, 30, 18, 24],\n    [301, 30, 19, 23],\n    [331, 30, 19, 23],\n    [361, 30, 19, 24],\n    [392, 30, 18, 24],\n  ],\n  \"walkDown\": [\n    [3, 31, 16, 22],\n    [33, 31, 16, 22],\n    [63, 30, 16, 23],\n    [93, 30, 16, 24],\n    [123, 31, 16, 22],\n    [153, 30, 16, 23],\n    [183, 30, 16, 23],\n    [213, 30, 16, 24],\n  ],\n  \"walkUp\": [\n    [2, 120, 17, 23],\n    [32, 120, 17, 24],\n    [62, 121, 17, 22],\n    [92, 121, 17, 22],\n    [122, 120, 17, 23],\n    [152, 120, 17, 24],\n    [182, 121, 17, 22],\n    [212, 121, 17, 22],\n  ],\n}\n\nconst WALK_POS_OFFSET = {\n  \"walkRight\": [[0, -1], [1, -1], [0, 0], [0, 0], [0, -1], [1, -1]],\n  \"walkLeft\": [[0, -1], [0, -1], [0, 0], [0, 0], [0, -1], [0, -1]],\n  \"walkDown\": [[0, 0], [0, 0], [0, -1], [0, -2], [0, 0], [0, -1], [0, -1], [0, -2]],\n  \"walkUp\": [[0, -1], [0, -2], [0, 0], [0, 0], [0, -1], [0, -2], [0, 0], [0, 0]],\n}\n\nconst STANDING = [\n  [331, 120, 19, 23],\n  [151, 0, 19, 23],\n  [33, 1, 16, 22],\n  [212, 121, 17, 22],\n]; //right left down up\n\nconst attack_directions = [\"attackRight\", \"attackLeft\", \"attackDown\", \"attackUp\"]\n\nconst ATTACK_X = {\n  \"attackRight\": [242, 268, 295, 327, 359],\n  \"attackLeft\": [242, 268, 295, 327, 359],\n  \"attackDown\": [1, 30, 61, 91, 115, 145],\n  \"attackUp\": [0, 30, 61, 89, 115],\n}\n\nconst ATTACK_Y = {\n  \"attackRight\": [180, 180, 181, 181, 176],\n  \"attackLeft\": [90, 90, 91, 91, 86],\n  \"attackDown\": [90, 90, 86, 86, 87, 88],\n  \"attackUp\": [181, 177, 174, 177, 180],\n}\n\nconst ATTACK_WIDTHS = {\n  \"attackRight\": [18, 26, 31, 28, 23],\n  \"attackLeft\": [18, 26, 31, 28, 23],\n  \"attackDown\": [20, 22, 20, 20, 28, 32],\n  \"attackUp\": [22, 22, 20, 24, 32],\n}\n\nconst ATTACK_HEIGHTS = {\n  \"attackRight\": [23, 24, 21, 21, 31],\n  \"attackLeft\": [23, 24, 21, 21, 31],\n  \"attackDown\": [23, 24, 31, 31, 29, 27],\n  \"attackUp\": [22, 30, 35, 30, 23],\n}\n\nconst ATTACK_POS_OFFSET = {\n  \"attackRight\": [[0, 0], [2, -1], [4, 2], [2, 2], [1, 1]],\n  \"attackLeft\": [[1, 0], [-10, -1], [-16, 2], [-12, 2], [-6, 1]],\n  \"attackDown\": [[-5, 0], [-6, 1], [-4, 1], [-4, 3], [-4, 1], [-4, 1]],\n  \"attackUp\": [[1, 0], [0, -8], [0, -13], [-4, -8], [-12, -1]],\n}\n\nconst bow_directions = [\"bowRight\", \"bowLeft\", \"bowDown\", \"bowUp\"];\n\nconst BOW_SPRITES = {\n  \"bowRight\": [\n    [242, 150, 17, 23],\n    [271, 151, 19, 22],\n    [301, 150, 20, 23],\n  ],\n  \"bowLeft\": [\n    [242, 60, 17, 23],\n    [271, 61, 19, 22],\n    [301, 60, 20, 23],\n  ],\n  \"bowDown\": [\n    [2, 60, 17, 24],\n    [32, 61, 18, 21],\n    [62, 61, 18, 22],\n  ],\n  \"bowUp\": [\n    [2, 151, 18, 22],\n    [30, 151, 21, 21],\n    [60, 151, 21, 22],\n  ],\n}\n\nconst BOW_POS_OFFSET = {\n  \"bowRight\": [[0, 0], [1, 1], [0, 0]],\n  \"bowLeft\": [[2, 0], [-1, 1], [-1, 0]],\n  \"bowDown\": [[0, 0], [0, 1], [0, 0]],\n  \"bowUp\": [[-2, 0], [-5, 1], [-5, 0]],\n}\n\nconst spin_directions = [\"spinRight\", \"spinLeft\", \"spinDown\", \"spinUp\"];\n\nconst SPIN_SPRITES = {\n  \"spinRight\": [\n    [879, 103, 23, 23, 1],\n    [835, 103, 31, 23, 1],\n    [791, 104, 34, 23, 1],\n    [747, 103, 34, 23, 1],\n    [715, 103, 23, 23, 1],\n    [689, 103, 16, 31, 2],\n    [656, 103, 28, 23, 0],\n    [624, 103, 28, 23, 0],\n    [596, 97, 17, 29, 3],\n    [559, 103, 28, 23, 1],\n    [529, 103, 28, 23, 1],\n    [500, 103, 23, 23, 1],\n  ],\n  \"spinLeft\": [\n    [500, 19, 23, 23, 0],\n    [536, 19, 31, 23, 0],\n    [577, 20, 34, 23, 0],\n    [621, 19, 34, 23, 0],\n    [664, 19, 23, 23, 0],\n    [697, 19, 16, 31, 2],\n    [718, 19, 28, 23, 1],\n    [750, 19, 28, 23, 1],\n    [789, 13, 17, 29, 3],\n    [815, 19, 28, 23, 0],\n    [845, 19, 28, 23, 0],\n    [879, 19, 23, 23, 0],\n  ],\n  \"spinDown\": [\n    [504, 139, 20, 26, 3],\n    [532, 126, 15, 36, 3],\n    [554, 126, 16, 39, 3],\n    [576, 138, 20, 26, 3],\n    [604, 142, 28, 22, 0],\n    [638, 142, 28, 22, 0],\n    [673, 141, 17, 31, 2],\n    [695, 142, 28, 22, 1],\n    [729, 142, 28, 22, 1],\n    [764, 136, 16, 28, 3],\n    [791, 138, 20, 26, 3],\n  ],\n  \"spinUp\": [\n    [487, 60, 20, 27, 2],\n    [516, 61, 15, 35, 2],\n    [541, 60, 17, 38, 2],\n    [568, 60, 17, 38, 2],\n    [595, 60, 20, 27, 2],\n    [620, 60, 28, 22, 1],\n    [657, 54, 16, 28, 3],\n    [681, 60, 28, 22, 0],\n    [720, 60, 16, 31, 2],\n    [746, 61, 17, 31, 2],\n    [767, 61, 20, 27, 2],\n    [797, 61, 17, 22, 2],\n  ],\n}\n\nconst SPIN_POS_OFFSET = {\n  \"spinRight\": [[-7, 0], [-14, 0], [-17, 1], [-16, 0], [-7, 0], [0, 0], [0, 0], [0, 0], [-1, -6], [-12, 0], [-12, 0], [-7, 0]],\n  \"spinLeft\": [[0, 0], [0, 1], [0, 0], [0, 0], [0, 0], [0, 0], [-12, 0], [-12, 0], [0, -6], [0, 0], [0, 0], [0, 0]],\n  \"spinDown\": [[0, -4], [0, -15], [-1, -15], [0, -5], [0, -1], [0, -1], [-1, -2], [-12, -1], [-12, -1], [0, -7], [0, -5], [0, -1]],\n  \"spinUp\": [[-4, 0], [0, 1], [0, 0], [0, 0], [-4, 0], [-12, 0], [0, -6], [0, 0], [0, 0], [-1, 1], [-4, 1], [0, 1]],\n}\n\nclass Link {\n  constructor(canvas, ctx) {\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.link = new Image();\n    this.link.src = './assets/link_sprites.png';\n    this.link2 = new Image();\n    this.link2.src = './assets/link-2.gif';\n    this.width = 19;\n    this.height = 23;\n    this.scale = 2.6;\n    this.scaledWidth = this.scale*this.width;\n    this.scaledHeight = this.scale*this.height;\n    this.position = [this.canvas.width/2 - this.scaledWidth/2, this.canvas.height/2];\n    this.currentDirection = 2;\n    this.currentLoopIndex = 0;\n    this.attackCurrentLoopIndex = 0;\n    this.bowCurrentLoopIndex = 0;\n    this.spinCurrentLoopIndex = 0;\n    this.frameCount = 0;\n    this.attackFrameCount = 0;\n    this.bowFrameCount = 0;\n    this.spinFrameCount = 0;\n    this.invFrameCount = 0;\n    this.keys = {};\n    this.attacking = false;\n    this.walking = false;\n    this.stunned = false;\n    this.invincible = false;\n    this.firingBow = false;\n    this.spinning = false;\n    this.ammo = 5;\n    this.life = 3;\n    this.right = false;\n    this.left = false;\n    this.down = false;\n    this.up = false;\n    this.spinPosX = this.position[0];\n    this.spinPosY = this.position[1];\n    this.attackDirection = this.currentDirection;\n    this.attackValue = 0;\n\n    this.swordSwingSounds = [\n      new Audio('./assets/LTTP_Sword1.wav'),\n      new Audio('./assets/LTTP_Sword2.wav')];\n    this.arrowShootSound = new Audio('./assets/LTTP_Arrow_Shoot.wav');\n    this.enemyHitSound = new Audio('./assets/LTTP_Enemy_Hit.wav');\n    this.linkHurtSound = new Audio('./assets/LTTP_Link_Hurt.wav');\n    this.getItemSound = new Audio('./assets/LTTP_Item.wav');\n\n    this.move = this.move.bind(this);\n    this.attack = this.attack.bind(this);\n    this.useBow = this.useBow.bind(this);\n    this.spin = this.spin.bind(this);\n    this.stopWalking = this.stopWalking.bind(this);\n    this.getMoveKeys = this.getMoveKeys.bind(this);\n    this.deleteMoveKeys = this.deleteMoveKeys.bind(this);\n  };\n\n  hitbox() {\n    return {\n      x: this.position[0],\n      y: this.position[1],\n      width: this.scaledWidth,\n      height: this.scaledHeight,\n    }\n  };\n\n  hurtbox() {\n    if (this.spinning) {\n      let allFrames = SPIN_SPRITES[spin_directions[this.currentDirection]];\n      let frame = allFrames[this.spinCurrentLoopIndex];\n      let xWidth = frame[2];\n      let yWidth = frame[3];\n      return {\n        x: this.spinPosX - 5,\n        y: this.spinPosY - 5,\n        width: xWidth * this.scale + 10,\n        height: yWidth * this.scale + 10,\n      }\n    }\n    else if (this.currentDirection === 0) {\n      return {\n        x: this.position[0] + this.scaledWidth,\n        y: this.position[1] - 3*this.scale,\n        width: 11*this.scale,\n        height: this.scaledHeight + 6*this.scale,\n      }\n    } else if (this.currentDirection === 1) {\n      return {\n        x: this.position[0] - 11*this.scale,\n        y: this.position[1] - 3*this.scale,\n        width: 11*this.scale,\n        height: this.scaledHeight + 6*this.scale,\n      }\n    } else if (this.currentDirection === 2) {\n      return {\n        x: this.position[0] - 6.5*this.scale,\n        y: this.position[1] + this.scaledHeight,\n        width: this.scaledWidth + 13*this.scale,\n        height: 4*this.scale,\n      }\n    } else {\n      return {\n        x: this.position[0] - 7.5*this.scale,\n        y: this.position[1] - 15*this.scale,\n        width: this.scaledWidth + 15*this.scale,\n        height: 6*this.scale,\n      }\n    }\n  }\n\n  collidedWith(object) {\n    let linkHit = this.hitbox()\n    let objectHit = object.hitbox()\n    if (\n      linkHit.x < objectHit.x + objectHit.width &&\n      linkHit.x + linkHit.width > objectHit.x &&\n      linkHit.y < objectHit.y + objectHit.height &&\n      linkHit.y + linkHit.height > objectHit.y\n      ) {\n        return true\n      } else {\n        return false\n    }\n  };\n\n  moveAwayFromObject(object) {\n    const linkHit = this.hitbox()\n    const objectHit = object.hitbox()\n\n    const linkBottom = linkHit.y + linkHit.height;\n    const objectBottom = objectHit.y + objectHit.height;\n    const linkRight = linkHit.x + linkHit.width;\n    const objectRight = objectHit.x + objectHit.width;\n\n    const bottomCollision = objectBottom - linkHit.y;\n    const topCollision = linkBottom - objectHit.y;\n    const leftCollision = linkRight - objectHit.x;\n    const rightCollision = objectRight - linkHit.x;\n\n    if (topCollision < bottomCollision && topCollision < leftCollision && topCollision < rightCollision ) {\n      this.position[1] = objectHit.y - linkHit.height\n    }\n    if (bottomCollision < topCollision && bottomCollision < leftCollision && bottomCollision < rightCollision) {\n      this.position[1] = objectBottom\n    }\n    if (leftCollision < rightCollision && leftCollision < topCollision && leftCollision < bottomCollision) {\n      this.position[0] = objectHit.x - linkHit.width\n    }\n    if (rightCollision < leftCollision && rightCollision < topCollision && rightCollision < bottomCollision ) {\n      this.position[0] = objectRight\n    }\n  };\n\n  attackedObject(object) {\n    let swordHit = this.hurtbox()\n    let objectHit = object.hitbox()\n    if ( this.attacking &&\n      swordHit.x < objectHit.x + objectHit.width &&\n      swordHit.x + swordHit.width > objectHit.x &&\n      swordHit.y < objectHit.y + objectHit.height &&\n      swordHit.y + swordHit.height > objectHit.y\n      ) {\n        this.enemyHitSound.play();\n        return true\n      } else {\n        return false\n    }\n  }\n\n  recoil(attackedSide) {\n    if (attackedSide === 0) {\n      this.position = [this.position[0] + 70, this.position[1]]\n    } else if (attackedSide === 1) {\n      this.position = [this.position[0] - 70, this.position[1]]\n    } else if (attackedSide === 2) {\n      this.position = [this.position[0], this.position[1] + 70]\n    } else {\n      this.position = [this.position[0], this.position[1] - 70]\n    }\n  }\n\n  damaged() {\n    this.walking = false;\n    // this.stunned = true;\n    this.invincible = true;\n    this.linkHurtSound.play();\n    // this.link.recoil();\n    this.life -= 1;\n    setTimeout(() => {this.stunned = false;}, 500) //stunned after hit\n    setTimeout(() => {this.invincible = false;}, 2000) //invincible for short time after getting hit\n  }\n\n  invincibility() {\n    if (this.invincible && !this.spinning) {\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n      this.invFrameCount++\n      if (this.invFrameCount < 5) {\n        return;\n      }\n      this.invFrameCount = 0;\n\n      if (this.attacking) {\n        this.swing();\n      } else if (this.walking) {\n        this.step();\n      } else if (this.firingBow) {\n        this.fireBow();\n      } else {\n        this.drawStand();\n      }\n    }\n  }\n\n  //moving\n\n  drawWalkFrame(frame, frameCount) {\n    let walkPosX = this.position[0] + WALK_POS_OFFSET[directions[this.currentDirection]][frameCount][0]*this.scale;\n    let walkPosY = this.position[1] + WALK_POS_OFFSET[directions[this.currentDirection]][frameCount][1]*this.scale;\n\n    this.ctx.drawImage(\n      this.link,\n      frame[0],\n      frame[1],\n      frame[2],\n      frame[3],\n      walkPosX,\n      walkPosY,\n      this.scale*frame[2],\n      this.scale*frame[3],\n    )\n    // this.ctx.beginPath();\n    // this.ctx.rect(this.position[0], this.position[1], this.scaledWidth, this.scaledHeight)\n    // this.ctx.lineWidth = 1\n    // this.ctx.strokeStyle = 'yellow';\n    // this.ctx.stroke();\n  };\n\n  step() {\n    if (this.walking && !this.attacking && !this.spinning && !this.firingBow) {\n      let allFrames = WALK_SPRITES[directions[this.currentDirection]];\n      let numFrames = allFrames.length;\n      if (this.frameCount < 3) {\n        if (this.currentLoopIndex >= numFrames) {\n          this.currentLoopIndex = 0;\n        }\n        this.drawWalkFrame(allFrames[this.currentLoopIndex], this.currentLoopIndex);\n        this.frameCount++;\n        return;\n      }\n      this.frameCount = 0;\n      this.currentLoopIndex++;\n      if (this.currentLoopIndex >= numFrames) {\n        this.currentLoopIndex = 0;\n      }\n      this.drawWalkFrame(allFrames[this.currentLoopIndex], this.currentLoopIndex);\n    }\n  };\n\n  getMoveKeys(e) {\n    e.preventDefault();\n    this.keys = (this.keys || []);\n    this.keys[e.keyCode] = true;\n    if (this.keys[40]) {\n      this.down = true;\n    }\n    if (this.keys[38]) {\n      this.up = true;\n    }\n    if (this.keys[37]) {\n      this.left = true;\n    }\n    if (this.keys[39]) {\n      this.right = true;\n    }\n  }\n\n  deleteMoveKeys(e) {\n    this.keys[e.keyCode] = false;\n    if (!this.keys[40]) {\n      this.down = false;\n    }\n    if (!this.keys[38]) {\n      this.up = false;\n    }\n    if (!this.keys[37]) {\n      this.left = false;\n    }\n    if (!this.keys[39]) {\n      this.right = false;\n    }\n  }\n\n  move() {\n    if (this.stunned || this.attacking || this.spinning || this.firingBow) {\n      return\n    }\n    if (this.down) {\n      this.walking = true\n      this.attacking = false;\n      this.firingBow = false;\n      this.position[1] += 3;\n      this.currentDirection = 2;\n    }\n    if (this.up) {\n      this.walking = true\n      this.attacking = false;\n      this.firingBow = false;\n      this.position[1] -= 3;\n      this.currentDirection = 3;\n    }\n    if (this.left) {\n      this.walking = true\n      this.attacking = false;\n      this.firingBow = false;\n      this.position[0] -= 3;\n      this.currentDirection = 1;\n    }\n    if (this.right) {\n      this.walking = true\n      this.attacking = false;\n      this.firingBow = false;\n      this.position[0] += 3;\n      this.currentDirection = 0;\n    }\n  };\n\n  //attacking\n\n  drawAttackFrame(direction, frame) {\n    let attackPosX = this.position[0] + ATTACK_POS_OFFSET[direction][frame][0]*this.scale;\n    let attackPosY = this.position[1] + ATTACK_POS_OFFSET[direction][frame][1]*this.scale;\n    let attackWidth = ATTACK_WIDTHS[direction][frame]\n    let attackHeight = ATTACK_HEIGHTS[direction][frame];\n\n    this.ctx.drawImage(\n      this.link,\n      ATTACK_X[direction][frame],\n      ATTACK_Y[direction][frame],\n      attackWidth,\n      attackHeight,\n      attackPosX,\n      attackPosY,\n      attackWidth*this.scale,\n      attackHeight*this.scale,\n    )\n    // this.ctx.beginPath();\n    // this.ctx.rect(attackPosX, attackPosY, attackWidth*this.scale, attackHeight*this.scale)\n    // this.ctx.lineWidth = 1\n    // this.ctx.strokeStyle = 'yellow';\n    // this.ctx.stroke();\n  };\n\n  swing() {\n    this.attackDirection = this.currentDirection;\n    if (this.attacking && !this.spinning) {\n      let numFrames = ATTACK_X[attack_directions[this.currentDirection]].length;\n      let cycleLoop = Array.from({length: numFrames}, (x,i) => i);\n      while (this.attackCurrentLoopIndex <= cycleLoop.length) {\n        if (this.attackFrameCount < 2) {\n          this.drawAttackFrame(\n            attack_directions[this.currentDirection],\n            cycleLoop[this.attackCurrentLoopIndex],\n          );\n          this.attackFrameCount++\n          return;\n        }\n        this.attackFrameCount = 0;\n\n        this.attackCurrentLoopIndex++;\n        if (this.attackCurrentLoopIndex === cycleLoop.length) {\n          break;\n        }\n\n        this.drawAttackFrame(\n          attack_directions[this.currentDirection],\n          cycleLoop[this.attackCurrentLoopIndex],\n        );\n      }\n      this.attackCurrentLoopIndex = 0;\n      this.attacking = false;\n    }\n  }\n\n  attack(e) {\n    e.preventDefault();\n    if ((this.stunned || this.firingBow || this.attacking || this.spinning)) {\n      return;\n    }\n    if (this.keys[32]) {\n      const swordSoundIdx = Math.floor(Math.random()*2)\n      this.swordSwingSounds[swordSoundIdx].play();\n      this.walking = false;\n      this.attacking = true;\n      this.attackValue = 1;\n    }\n  }\n\n  drawBowFrame(frame, frameCount) {\n    let bowPosX = this.position[0] + BOW_POS_OFFSET[bow_directions[this.currentDirection]][frameCount][0]*this.scale;\n    let bowPosY = this.position[1] + BOW_POS_OFFSET[bow_directions[this.currentDirection]][frameCount][1]*this.scale;\n\n    this.ctx.drawImage(\n      this.link,\n      frame[0],\n      frame[1],\n      frame[2],\n      frame[3],\n      bowPosX,\n      bowPosY,\n      frame[2]*this.scale,\n      frame[3]*this.scale,\n    )\n  }\n\n  fireBow() {\n    if (this.firingBow) {\n      let allFrames = BOW_SPRITES[bow_directions[this.currentDirection]]\n      let numFrames = allFrames.length\n      if (this.bowFrameCount < 5) {\n        this.drawBowFrame(allFrames[this.bowCurrentLoopIndex], this.bowCurrentLoopIndex),\n        this.bowFrameCount++;\n        return;\n      }\n      this.bowFrameCount = 0;\n      this.bowCurrentLoopIndex++;\n      if (this.bowCurrentLoopIndex >= numFrames) {\n        this.bowCurrentLoopIndex = 0\n        this.firingBow = false;\n        return\n      }\n      this.drawBowFrame(allFrames[this.bowCurrentLoopIndex], this.bowCurrentLoopIndex);\n    }\n  }\n\n  useBow(e) {\n    e.preventDefault();\n    if ((this.stunned || this.firingBow || this.attacking || this.spinning)) {\n      return;\n    }\n    if (this.keys[66] && this.ammo > 0) {\n      this.firingBow = true;\n      this.attackValue = 1;\n    }\n  }\n\n  spin(e) {\n    e.preventDefault();\n    if ((this.stunned || this.firingBow || this.attacking || this.spinning)) {\n      return;\n    }\n    if (this.keys[86]) {\n      this.spinning = true;\n      this.attackValue = 3;\n    }\n  }\n\n  spinAttack() {\n    if (this.spinning) {\n      this.attacking = true;\n      this.invincible = true;\n      let allFrames = SPIN_SPRITES[spin_directions[this.currentDirection]]\n      let numFrames = allFrames.length\n      if (this.spinFrameCount < 2) {\n        this.drawSpinFrame(allFrames[this.spinCurrentLoopIndex], this.spinCurrentLoopIndex),\n        this.spinFrameCount++;\n        return;\n      }\n      this.attackDirection = (allFrames[this.spinCurrentLoopIndex])[4]\n      this.spinFrameCount = 0;\n      this.spinCurrentLoopIndex++;\n      if (this.spinCurrentLoopIndex >= numFrames) {\n        this.spinCurrentLoopIndex = 0\n        this.spinning = false;\n        this.attacking = false;\n        this.invincible = false;\n        return\n      }\n      this.drawSpinFrame(allFrames[this.spinCurrentLoopIndex], this.spinCurrentLoopIndex);\n    }\n  }\n\n  drawSpinFrame(frame, frameCount) {\n    this.spinPosX = this.position[0] + SPIN_POS_OFFSET[spin_directions[this.currentDirection]][frameCount][0]*this.scale;\n    this.spinPosY = this.position[1] + SPIN_POS_OFFSET[spin_directions[this.currentDirection]][frameCount][1]*this.scale;\n    this.ctx.drawImage(\n      this.link2,\n      frame[0],\n      frame[1],\n      frame[2],\n      frame[3],\n      this.spinPosX,\n      this.spinPosY,\n      frame[2]*this.scale,\n      frame[3]*this.scale,\n    )\n\n    // this.ctx.beginPath();\n    // this.ctx.rect(this.spinPosX, this.spinPosY, frame[2]*this.scale, frame[3]*this.scale)\n    // this.ctx.lineWidth = 1\n    // this.ctx.strokeStyle = 'yellow';\n    // this.ctx.stroke();\n  }\n\n  drawStand() {\n    this.ctx.drawImage(\n      this.link,\n      STANDING[this.currentDirection][0],\n      STANDING[this.currentDirection][1],\n      STANDING[this.currentDirection][2],\n      STANDING[this.currentDirection][3],\n      this.position[0],\n      this.position[1],\n      STANDING[this.currentDirection][2]*this.scale,\n      STANDING[this.currentDirection][3]*this.scale,\n    );\n\n    // this.ctx.beginPath();\n    // this.ctx.rect(this.position[0], this.position[1], STANDING[this.currentDirection][2]*this.scale, STANDING[this.currentDirection][3]*this.scale)\n    // this.ctx.lineWidth = 1\n    // this.ctx.strokeStyle = 'yellow';\n    // this.ctx.stroke();\n  }\n\n  stand() {\n    if ((this.walking || this.attacking || this.firingBow || this.spinning) === false) {\n      this.drawStand();\n    }\n  }\n\n  pickUpItem(item) {\n    this.getItemSound.play();\n    if (item instanceof ArrowItem) {\n      this.ammo += item.value;\n    } else if (item instanceof HeartItem && this.life < 5) {\n      this.life++;\n    }\n  }\n\n  preventOffscreen() {\n    if (this.position[0] < 0) {\n      this.position[0] = 0\n    }\n    if (this.position[0] + this.scaledWidth > this.canvas.width) {\n      this.position[0] = this.canvas.width - this.scaledWidth\n    }\n    if (this.position[1] < 0) {\n      this.position[1] = 0\n    }\n    if (this.position[1] + this.scaledHeight > this.canvas.height) {\n      this.position[1] = this.canvas.height - this.scaledHeight\n    }\n  }\n\n  stopWalking(e) {\n    this.walking = false;\n  }\n\n  draw() {\n    this.preventOffscreen();\n    this.swing();\n    this.step();\n    this.fireBow();\n    this.spinAttack();\n    this.stand();\n    this.invincibility();\n  };\n}\n\nexport default Link;\n","import Enemy from './enemy';\n\nconst moblin_directions = [\"walkRight\", \"walkLeft\", \"walkDown\", \"walkUp\"];\n\nconst MOBLIN_SPRITES = {\n  \"walkRight\": [\n    [160, 0, 24, 26],\n    [160, 40, 24, 26],\n    // [160, 80, 24, 26],\n  ],\n  \"walkLeft\": [\n    [222, 14, 24, 26],\n    [222, 54, 24, 26],\n    // [222, 94, 24, 26],\n  ],\n  \"walkDown\": [\n    [124, 0, 17, 32],\n    [124, 38, 17, 32],\n    // [123, 81, 17, 32],\n  ],\n  \"walkUp\": [\n    [203, 0, 18, 28],\n    [203, 40, 18, 28],\n    // [203, 80, 18, 30],\n  ],\n};\n\nclass Moblin extends Enemy {\n  constructor(canvas, ctx, pos) {\n    super(canvas, ctx, pos);\n    this.currentDirection = 2;\n    this.moblin = new Image();\n    this.moblin.src = './assets/enemies.png';\n    this.currentLoopIndex = 0;\n    this.frameCount = 0;\n    this.life = 2;\n    this.speed = .1 + Math.random();\n    this.width = 24;\n    this.height = 26;\n    this.scaledWidth = this.width*this.scale;\n    this.scaledHeight = this.height*this.scale;\n  }\n\n  hitbox() {\n    return {\n      x: this.position[0],\n      y: this.position[1],\n      width: this.scaledWidth,\n      height: this.scaledHeight,\n    }\n  };\n\n  move(player) {\n    this.moveTowardsObject(player)\n  }\n\n  step() {\n    if (this.poofing) {\n      return\n    }\n    let allFrames = MOBLIN_SPRITES[moblin_directions[this.currentDirection]]\n    let numFrames = allFrames.length;\n    if (this.frameCount < 8) {\n      this.width = allFrames[2];\n      this.height = allFrames[3];\n      this.drawWalkFrame(allFrames[this.currentLoopIndex])\n      this.frameCount++;\n      return\n    }\n    this.frameCount = 0;\n    this.currentLoopIndex++;\n    if (this.currentLoopIndex >= numFrames) {\n      this.currentLoopIndex = 0;\n    }\n    this.drawWalkFrame(allFrames[this.currentLoopIndex])\n  }\n\n  drawWalkFrame(frame) {\n    this.ctx.drawImage(\n      this.moblin,\n      frame[0],\n      frame[1],\n      frame[2],\n      frame[3],\n      this.position[0],\n      this.position[1],\n      this.scale*frame[2],\n      this.scale*frame[3],\n    )\n    // this.ctx.beginPath();\n    // this.ctx.rect(this.position[0], this.position[1], this.scale*frame[2], this.scale*frame[3])\n    // this.ctx.lineWidth = 1\n    // this.ctx.strokeStyle = 'yellow';\n    // this.ctx.stroke();\n  }\n\n  draw() {\n    if (this.flashing) {\n      this.flashFrameCount++\n      if (this.flashFrameCount < 5) {\n        return;\n      }\n      this.flashFrameCount = 0;\n    }\n    this.step();\n    this.poof();\n  }\n}\n\nexport default Moblin;\n","class Obstacle {\n  constructor(pos, width, height) {\n    this.position = pos;\n    this.width = width;\n    this.height = height;\n    this.scale = 2;\n  }\n\n  hitbox() {\n    return {\n      x: this.position[0]*this.scale,\n      y: this.position[1]*this.scale,\n      width: this.width*this.scale,\n      height: this.height*this.scale,\n    }\n  };\n}\n\nexport default Obstacle;\n","import Game from './game.js';\nimport Info from './info.js';\n\ndocument.addEventListener('DOMContentLoaded', ()=> {\n  const mainCanvas = document.getElementsByClassName('game-canvas')[0];\n  const infoCanvas = document.getElementsByClassName('info-canvas')[0];\n  const ctx = mainCanvas.getContext('2d');\n  const ctxInfo = infoCanvas.getContext('2d');\n\n\n  const game = new Game(mainCanvas, ctx);\n  const info = new Info(infoCanvas, ctxInfo, game)\n  game.openMenu();\n  info.loop();\n});\n","import Enemy from './enemy';\n\nconst WALLMASTER_SPRITES = [\n  [280, 883, 24, 22],\n  [318, 883, 24, 22]\n]\n\nclass Wallmaster extends Enemy {\n  constructor(canvas, ctx, pos) {\n    super(canvas, ctx, pos);\n    this.currentDirection = 0;\n    this.wallmaster = new Image();\n    this.wallmaster.src = './assets/enemies.png';\n    this.currentLoopIndex = 0;\n    this.walkCycle = 0;\n    this.frameCount = -1;\n    this.life = 3;\n    this.speed = Math.random()*.8;\n    this.width = 24;\n    this.height = 22;\n    this.scaledWidth = this.width*this.scale;\n    this.scaledHeight = this.height*this.scale;\n  }\n\n  hitbox() {\n    return {\n      x: this.position[0],\n      y: this.position[1],\n      width: this.scaledWidth,\n      height: this.scaledHeight,\n    }\n  };\n\n  move(player) {\n    this.moveTowardsObject(player)\n  }\n\n  step() {\n    if (this.poofing) {\n      return\n    }\n    if (this.frameCount < 9) {\n      this.frameCount++\n    } else {\n      this.walkCycle = (this.walkCycle === 1 ? 0 : 1)\n      this.frameCount = 0;\n    }\n\n    let sprite = this.getSprite();\n    this.ctx.drawImage(\n      this.wallmaster,\n      sprite[0],\n      sprite[1],\n      sprite[2],\n      sprite[3],\n      this.position[0],\n      this.position[1],\n      this.scale*sprite[2],\n      this.scale*sprite[3],\n    )\n  }\n\n  getSprite() {\n    if (this.walkCycle === 0) {\n      return WALLMASTER_SPRITES[0]\n    } else {\n      return WALLMASTER_SPRITES[1]\n    }\n  }\n\n  draw() {\n    if (this.flashing) {\n      this.flashFrameCount++\n      if (this.flashFrameCount < 5) {\n        return;\n      }\n      this.flashFrameCount = 0;\n    }\n    this.step();\n    this.poof();\n  }\n}\n\nexport default Wallmaster;\n"],"sourceRoot":""}