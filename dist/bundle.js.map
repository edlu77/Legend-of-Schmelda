{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./lib/arrow.js","webpack:///./lib/enemy.js","webpack:///./lib/game.js","webpack:///./lib/link.js","webpack:///./lib/schmelda.js","webpack:///./lib/wallmaster.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEe,oEAAK,EAAC;;;;;;;;;;;;;ACxFrB;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEe,oEAAK,EAAC;;;;;;;;;;;;;AClErB;AAAA;AAAA;AAAA;AAAyC;AACZ;AACE;;AAE/B;AACA;AACA;AACA,oBAAoB,gDAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,sDAAU;AACtC;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP,6BAA6B,iDAAK;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,2BAA2B;AAC9C,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEe,mEAAI,EAAC;;;;;;;;;;;;;ACxLpB;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C,sBAAsB,yBAAyB;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,kBAAkB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,mEAAI,EAAC;;;;;;;;;;;;;AC/fpB;AAAA;AAA6B;;AAE7B;AACA;AACA;;AAEA,mBAAmB,gDAAI;AACvB;AACA,CAAC;;;;;;;;;;;;;ACRD;AAAA;AAA4B;;AAE5B;AACA;AACA;AACA;;AAEA,yBAAyB,8CAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,yEAAU,EAAC","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./lib/schmelda.js\");\n","const ARROW_SPRITES = [\n  [295, 376, 15, 5],\n  [194, 354, 15, 5],\n  [401, 104, 5, 15],\n  [395, 344, 5, 15],\n] //left(invert), right, down, up\n\nclass Arrow {\n  constructor(canvas, ctx, pos, direction) {\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.position = pos;\n    this.scale = 1.5;\n    this.arrow = new Image();\n    this.arrow.src = './assets/link-2.gif';\n    this.direction = direction;\n    this.width = (this.direction === 0 || this.direction === 1) ? 15 : 5;\n    this.height = (this.direction === 1 || this.direction === 0) ? 5 : 15;\n\n    this.move = this.move.bind(this);\n  }\n\n  hitbox() {\n    return {\n      x: this.position[0],\n      y: this.position[1],\n      width: this.width,\n      height: this.height,\n    }\n  };\n\n  collidedWith(object) {\n    let enemyHit = this.hitbox()\n    let objectHit = object.hitbox()\n    if (enemyHit.x < objectHit.x + objectHit.width && enemyHit.x + enemyHit.width > objectHit.x\n        && enemyHit.y < objectHit.y + objectHit.height && enemyHit.y + enemyHit.height > objectHit.y) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  getSprite() {\n    return ARROW_SPRITES[this.direction]\n  }\n\n  move() {\n    if (this.direction === 0) {\n      this.position[0] += 5;\n    } else if (this.direction === 1) {\n      this.position[0] -= 5;\n    } else if (this.direction === 2) {\n      this.position[1] += 5;\n    } else {\n      this.position[1] -= 5;\n    }\n  }\n\n  draw() {\n    let sprite = this.getSprite();\n    // this.ctx.clearRect(this.position[0], this.position[1], this.hitbox().width, this.hitbox().height)\n    // this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n    this.ctx.drawImage(\n      this.arrow,\n      sprite[0],\n      sprite[1],\n      sprite[2],\n      sprite[3],\n      this.position[0],\n      this.position[1],\n      this.scale*sprite[2],\n      this.scale*sprite[3],\n    )\n  }\n\n  isOffscreen() {\n    if (\n      this.position[0] > this.canvas.width ||\n      this.position[0] + this.width < 0 ||\n      this.position[1] + this.height < 0 ||\n      this.position[1] > this.canvas.height) {\n      return true\n    } else {\n      return false\n    }\n  }\n}\n\nexport default Arrow;\n","class Enemy {\n  constructor(canvas, ctx, pos) {\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.position = pos;\n    this.enemyDeathSound = new Audio('./assets/LTTP_Enemy_Kill.wav')\n  }\n\n  recoil(attackedSide) {\n    if (attackedSide === 0) {\n      this.position = [this.position[0] + 50, this.position[1]]\n    } else if (attackedSide === 1) {\n      this.position = [this.position[0] - 50, this.position[1]]\n    } else if (attackedSide === 2) {\n      this.position = [this.position[0], this.position[1] + 50]\n    } else {\n      this.position = [this.position[0], this.position[1] - 50]\n    };\n    this.ctx.fillStyle = 'red';\n    this.ctx.fill();\n  };\n\n  isDead() {\n    if (this.life === 0) {\n      this.enemyDeathSound.play();\n      return true;\n    }\n  };\n\n  hitbox() {\n    return {\n      x: this.position[0],\n      y: this.position[1],\n      width: this.width,\n      height: this.height,\n    }\n  };\n\n  collidedWith(object) {\n    let enemyHit = this.hitbox()\n    let objectHit = object.hitbox()\n    if (enemyHit.x < objectHit.x + objectHit.width && enemyHit.x + enemyHit.width > objectHit.x\n        && enemyHit.y < objectHit.y + objectHit.height && enemyHit.y + enemyHit.height > objectHit.y) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  moveAwayFromObject(object) {\n    if (object.position[0] < this.position[0]) {\n      this.position[0] += 1;\n    }\n    if (object.position[1] < this.position[1]) {\n      this.position[1] += 1;\n    }\n    if (object.position[0] > this.position[0]) {\n      this.position[0] -= 1;\n    }\n    if (object.position[1] > this.position[1]) {\n      this.position[1] -= 1;\n    }\n  };\n\n};\n\nexport default Enemy;\n","import Wallmaster from './wallmaster.js';\nimport Link from './link.js';\nimport Arrow from './arrow.js';\n\nclass Game {\n  constructor(canvas, ctx) {\n    this.enemies = [];\n    this.link = new Link(canvas, ctx);\n    this.ctx = ctx;\n    this.canvas = canvas;\n    this.draw = this.draw.bind(this);\n    this.loop = this.loop.bind(this);\n    this.keys = [];\n    this.arrows = [];\n    this.oldTime = Date.now();\n    this.linkHurtSound = new Audio('./assets/LTTP_Link_Hurt.wav');\n    this.arrowHitSound = new Audio('./assets/LTTP_Arrow_Hit.wav');\n\n    this.makeEnemy = this.makeEnemy.bind(this);\n    this.makeArrow = this.makeArrow.bind(this);\n\n    this.combineListeners();\n    setInterval(this.makeEnemy, 3000)\n  }\n\n\n  combineListeners() {\n    document.addEventListener('keydown', this.link.getMoveKeys);\n    document.addEventListener('keydown', this.link.move);\n    document.addEventListener('keyup', this.link.deleteMoveKeys);\n    document.addEventListener('keyup', this.link.stopWalking);\n    document.addEventListener('keydown', this.link.attack);\n    document.addEventListener('keydown', this.link.useBow)\n  }\n\n  loop() {\n    this.update();\n    this.draw();\n    window.requestAnimationFrame(this.loop)\n  }\n\n  update() {\n    this.gameOver();\n    this.updateEnemies();\n    this.avoidOverlap();\n    this.updateArrows();\n    this.makeArrow();\n  }\n\n  draw() {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n    this.link.draw();\n    this.drawEnemies();\n    this.drawArrows();\n  }\n\n  makeEnemy() {\n    if (this.enemies.length < 12) {\n      this.enemies.push(new Wallmaster(this.canvas, this.ctx, this.enemySpawnPos()));\n    }\n  }\n\n  updateEnemies() {\n    for (let i = 0; i < this.enemies.length; i++) {\n      //clear any dead enemies from the state\n      if (this.enemies[i].isDead()) {\n        this.enemies.splice(i, 1);\n      }\n      if (this.enemies[i]) {\n        this.enemies[i].move(this.link);\n        if (this.link.collidedWith(this.enemies[i]) && this.link.invincible === false) {\n          this.linkHurtSound.play();\n          // this.link.recoil();\n          this.link.life -= 1;\n          this.link.damaged();\n          console.log(this.link.life)\n        }\n        if (this.link.attackedObject(this.enemies[i])) {\n          this.enemies[i].recoil(this.link.currentDirection);\n          this.enemies[i].life -= 1\n        }\n        //check for arrow hits\n        for (let j = 0; j < this.arrows.length; j++) {\n          if (this.enemies[i].collidedWith(this.arrows[j])) {\n            this.arrowHitSound.play();\n            this.enemies[i].recoil(this.arrows[j].direction);\n            this.enemies[i].life -= 1;\n            this.arrows.splice(j, 1);\n          }\n        }\n      }\n    }\n  }\n\n  drawEnemies() {\n    for (let i = 0; i < this.enemies.length; i++) {\n      this.enemies[i].draw();\n    }\n  }\n\n  makeArrow() {\n    if (this.link.firingBow === true) {\n      let startPos = this.link.position.slice(0);\n      if (this.link.currentDirection === 0) {\n        startPos[0] += this.link.scaledWidth;\n        startPos[1] += this.link.scaledHeight/2;\n      } else if (this.link.currentDirection === 1) {\n        startPos[0] -= 20;\n        startPos[1] = startPos[1] + this.link.scaledHeight/2;\n      } else if (this.link.currentDirection === 2) {\n        startPos[0] += this.link.scaledWidth/2;\n        startPos[1] += this.link.scaledHeight;\n      } else {\n        startPos[0] += this.link.scaledWidth/2;\n        startPos[1] -= 20;\n      }\n\n      if (this.arrowLimit()) {\n        return\n      } else {\n\n        this.arrows.push(new Arrow(this.canvas, this.ctx, startPos, this.link.currentDirection));\n        this.link.ammo -= 1;\n        console.log(this.link.ammo);\n      }\n    }\n  }\n\n  arrowLimit() {\n    if (Date.now() - this.oldTime < 500) {\n      return true\n    }\n    this.oldTime = Date.now();\n  }\n\n  updateArrows() {\n    for (let i = 0; i < this.arrows.length; i++) {\n      if (this.arrows[i].isOffscreen()) {\n        this.arrows.splice(i, 1);\n      }\n      if (this.arrows[i]) {\n        this.arrows[i].move();\n      }\n    }\n  }\n\n  drawArrows() {\n    for (let i = 0; i < this.arrows.length; i++) {\n      this.arrows[i].draw();\n    }\n  }\n\n  enemySpawnPos() {\n    const wall = Math.floor(Math.random()*4);\n    switch (wall) {\n      case 0:\n        return [-50, Math.random()*this.canvas.height]\n      case 1:\n        return [this.canvas.width+50, Math.random()*this.canvas.height]\n      case 2:\n        return [Math.random()*this.canvas.width, this.canvas.height+ 50]\n      case 3:\n        return [Math.random()*this.canvas.width, -50]\n    }\n  }\n\n  avoidOverlap() {\n    for (let i = 0; i < this.enemies.length-1; i++) {\n      for (let j = i+1; j < this.enemies.length; j++) {\n        if (this.enemies[i].collidedWith(this.enemies[j])) {\n          this.enemies[i].moveAwayFromObject(this.enemies[j])\n          this.enemies[j].moveAwayFromObject(this.enemies[i])\n        }\n      }\n    }\n  }\n\n  gameOver() {\n    if (this.link.life === 0) {\n      console.log(\"You have died!\")\n    }\n  }\n}\n\nexport default Game;\n","const directions = [\"walkRight\", \"walkLeft\", \"walkDown\", \"walkUp\"]\n\nconst WALK_X = {\n  \"walkRight\": [241, 271, 301, 331, 361, 391],\n  \"walkLeft\": [241, 271, 301, 331, 361, 391],\n  \"walkDown\": [0, 30, 60, 90, 120, 150, 180, 210],\n  \"walkUp\": [0, 30, 60, 90, 120, 150, 180, 210],\n};\n\nconst WALK_Y = {\n  \"walkRight\": 120,\n  \"walkLeft\": 30,\n  \"walkDown\": 30,\n  \"walkUp\": 120,\n};\n\nconst STANDING = [\n  [331, 120],\n  [151, 0],\n  [31, 0],\n  [210, 120],\n]; //right left down up\n\nconst attack_directions = [\"attackRight\", \"attackLeft\", \"attackDown\", \"attackUp\"]\n\nconst ATTACK_X = {\n  \"attackRight\": [242, 268, 295, 328, 360],\n  \"attackLeft\": [242, 268, 295, 327, 359],\n  \"attackDown\": [0, 30, 60, 90, 115, 145],\n  \"attackUp\": [0, 30, 60, 88, 115],\n}\n\nconst ATTACK_Y = {\n  \"attackRight\": [180, 180, 180, 180, 175],\n  \"attackLeft\": [90, 90, 90, 90, 84],\n  \"attackDown\": [90, 90, 86, 86, 86, 86],\n  \"attackUp\": [174, 177, 174, 177, 180],\n}\n\nconst ATTACK_WIDTHS = {\n  \"attackRight\": [18, 26, 31, 28, 23],\n  \"attackLeft\": [18, 26, 31, 28, 23],\n  \"attackDown\": [21, 22, 21, 20, 28, 33],\n  \"attackUp\": [21, 21, 21, 24, 35],\n}\n\nconst ATTACK_HEIGHTS = {\n  \"attackRight\": [23, 24, 22, 22, 31],\n  \"attackLeft\": [23, 24, 22, 22, 31],\n  \"attackDown\": [23, 24, 31, 31, 29, 27],\n  \"attackUp\": [22, 30, 35, 30, 23],\n}\n\nconst ATTACK_POS_OFFSET = {\n  \"attackRight\": [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],\n  \"attackLeft\": [[-2, 0], [-10, 0], [-13, 0], [-13, 0], [-7, 0]],\n  \"attackDown\": [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],\n  \"attackUp\": [[0, 0], [0, -7], [0, -8], [-4, -6], [-12, -1]],\n}\n\nconst bow_directions = [\"bowRight\", \"bowLeft\", \"bowDown\", \"bowUp\"];\n\nconst BOW_SPRITES = {\n  \"bowRight\": [\n    [117, 367, 20, 24],\n    [143, 367, 19, 24],\n    [169, 367, 17, 24],\n  ],\n  \"bowLeft\": [\n    [168, 342, 20, 24],\n    [143, 342, 19, 24],\n    [119, 342, 17, 24],\n  ],\n  \"bowDown\": [\n    [324, 95, 17, 24],\n    [348, 95, 18, 24],\n    [372, 95, 19, 24],\n  ],\n  \"bowUp\": [\n    [316, 342, 18, 22],\n    [338, 342, 21, 22],\n    [362, 342, 21, 22],\n  ],\n}\n\nclass Link {\n  constructor(canvas, ctx) {\n    this.canvas = canvas;\n    this.ctx = ctx;\n    this.link = new Image();\n    this.link.src = './assets/link_sprites.png';\n    this.link2 = new Image();\n    this.link2.src = './assets/link-2.gif';\n    this.width = 20;\n    this.height = 25;\n    this.scale = 2.6;\n    this.scaledWidth = this.scale*this.width;\n    this.scaledHeight = this.scale*this.height;\n    this.currentLoopIndex = 0;\n    this.attackCurrentLoopIndex = 0;\n    this.bowCurrentLoopIndex = 0;\n    this.position = [this.canvas.width/2 - this.scaledWidth/2, this.canvas.height*.6];\n    this.currentDirection = 3;\n    this.frameCount = 0;\n    this.attackFrameCount = 0;\n    this.bowFrameCount = 0;\n    this.invFrameCount = 0;\n    this.keys = {};\n    this.attacking = false;\n    this.walking = false;\n    this.stunned = false;\n    this.invincible = false;\n    this.firingBow = false;\n    this.ammo = 100000;\n    this.life = 3;\n\n    this.swordSwingSounds = [\n      new Audio('./assets/LTTP_Sword1.wav'),\n      new Audio('./assets/LTTP_Sword2.wav')];\n    this.arrowShootSound = new Audio('./assets/LTTP_Arrow_Shoot.wav');\n    this.enemyHitSound = new Audio('./assets/LTTP_Enemy_Hit.wav');\n\n    this.move = this.move.bind(this);\n    this.attack = this.attack.bind(this);\n    this.useBow = this.useBow.bind(this);\n    this.stopWalking = this.stopWalking.bind(this);\n    this.getMoveKeys = this.getMoveKeys.bind(this);\n    this.deleteMoveKeys = this.deleteMoveKeys.bind(this);\n    this.fireBow = this.fireBow.bind(this);\n  };\n\n  hitbox() {\n    return {\n      x: this.position[0],\n      y: this.position[1],\n      width: this.scaledWidth,\n      height: this.scaledHeight,\n    }\n  };\n\n  hurtbox() {\n    if (this.currentDirection === 0) {\n      return {\n        x: this.position[0] + this.scaledWidth,\n        y: this.position[1],\n        width: 8*this.scale,\n        height: this.scaledHeight,\n      }\n    } else if (this.currentDirection === 1) {\n      return {\n        x: this.position[0] - 8*this.scale,\n        y: this.position[1],\n        width: 8*this.scale,\n        height: this.scaledHeight,\n      }\n    } else if (this.currentDirection === 2) {\n      return {\n        x: this.position[0],\n        y: this.position[1] + this.scaledHeight,\n        width: this.scaledWidth,\n        height: 7*this.scale,\n      }\n    } else {\n      return {\n        x: this.position[0],\n        y: this.position[1] - 7*this.scale,\n        width: this.scaledWidth,\n        height: 6*this.scale,\n      }\n    }\n  }\n\n  collidedWith(object) {\n    let linkHit = this.hitbox()\n    let objectHit = object.hitbox()\n    if (\n      linkHit.x < objectHit.x + objectHit.width &&\n      linkHit.x + linkHit.width > objectHit.x &&\n      linkHit.y < objectHit.y + objectHit.height &&\n      linkHit.y + linkHit.height > objectHit.y\n      ) {\n        return true\n      } else {\n        return false\n    }\n  };\n\n  attackedObject(object) {\n    let swordHit = this.hurtbox()\n    let objectHit = object.hitbox()\n    if ( this.attacking &&\n      swordHit.x < objectHit.x + objectHit.width &&\n      swordHit.x + swordHit.width > objectHit.x &&\n      swordHit.y < objectHit.y + objectHit.height &&\n      swordHit.y + swordHit.height > objectHit.y\n      ) {\n        this.enemyHitSound.play();\n        return true\n      } else {\n        return false\n    }\n  }\n\n  recoil(attackedSide) {\n    if (attackedSide === 0) {\n      this.position = [this.position[0] + 70, this.position[1]]\n    } else if (attackedSide === 1) {\n      this.position = [this.position[0] - 70, this.position[1]]\n    } else if (attackedSide === 2) {\n      this.position = [this.position[0], this.position[1] + 70]\n    } else {\n      this.position = [this.position[0], this.position[1] - 70]\n    }\n  }\n\n  damaged() {\n    this.walking = false;\n    this.stunned = true;\n    this.invincible = true;\n    setTimeout(() => {this.stunned = false;}, 500) //stunned after hit\n    setTimeout(() => {this.invincible = false;}, 2000) //invincible for short time after getting hit\n  }\n\n  invincibility() {\n    if (this.invincible === true) {\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\n      this.invFrameCount++\n      if (this.invFrameCount < 5) {\n        return;\n      }\n      this.invFrameCount = 0;\n\n      if (this.attacking === true) {\n        this.swing();\n      } else if (this.walking === true) {\n        this.step();\n      } else if (this.firingBow === true) {\n        this.fireBow();\n      } else {\n        this.drawStand();\n      }\n    }\n  }\n\n  oppositeDirection() {\n    switch (this.currentDirection) {\n      case 0:\n        return 1;\n      case 1:\n        return 0;\n      case 2:\n        return 3;\n      case 3:\n        return 2;\n    }\n  }\n\n  //moving\n\n  drawWalkFrame(direction, frame) {\n    this.ctx.drawImage(\n      this.link,\n      WALK_X[direction][frame],\n      WALK_Y[direction],\n      this.width,\n      this.height,\n      this.position[0],\n      this.position[1],\n      this.scaledWidth,\n      this.scaledHeight,\n    )\n    // this.ctx.beginPath();\n    // this.ctx.rect(this.position[0], this.position[1], this.scaledWidth, this.scaledHeight)\n    // this.ctx.lineWidth = 1\n    // this.ctx.strokeStyle = 'yellow';\n    // this.ctx.stroke();\n  };\n\n  step() {\n    if (this.walking === true) {\n      let numFrames = WALK_X[directions[this.currentDirection]].length\n      let cycleLoop = Array.from({length: numFrames}, (x,i) => i);\n\n      if (this.frameCount < 5) {\n        this.drawWalkFrame(\n          directions[this.currentDirection],\n          cycleLoop[this.currentLoopIndex],\n        );\n        this.frameCount++\n        return\n      }\n      this.frameCount = 0;\n      this.currentLoopIndex++;\n      // this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.width)\n      this.drawWalkFrame(\n        directions[this.currentDirection],\n        cycleLoop[this.currentLoopIndex],\n      );\n      if (this.currentLoopIndex >= cycleLoop.length) {\n        this.currentLoopIndex = 0;\n      }\n    }\n    this.frameCount = 0;\n  };\n\n  getMoveKeys(e) {\n    this.keys = (this.keys || []);\n    this.keys[e.keyCode] = true;\n  }\n\n  deleteMoveKeys(e) {\n    this.keys[e.keyCode] = false;\n  }\n\n  move(e) {\n    if (this.stunned === true || this.attacking === true) {\n      return\n    }\n    if (this.keys[65] === true) {\n      this.walking = true\n      this.attacking = false;\n      this.position[0] -= 15;\n      this.currentDirection = 1;\n    }\n    if (this.keys[68] === true) {\n      this.walking = true\n      this.attacking = false;\n      this.position[0] += 15;\n      this.currentDirection = 0;\n    }\n    if (this.keys[83] === true) {\n      this.walking = true\n      this.attacking = false;\n      this.position[1] += 15;\n      this.currentDirection = 2;\n    }\n    if (this.keys[87] === true) {\n      this.walking = true\n      this.attacking = false;\n      this.position[1] -= 15;\n      this.currentDirection = 3;\n    }\n\n  };\n\n  //attacking\n\n  drawAttackFrame(direction, frame) {\n    let attackPosX = this.position[0] + ATTACK_POS_OFFSET[direction][frame][0]*this.scale;\n    let attackPosY = this.position[1] + ATTACK_POS_OFFSET[direction][frame][1]*this.scale;\n    let attackWidth = ATTACK_WIDTHS[direction][frame]\n    let attackHeight = ATTACK_HEIGHTS[direction][frame];\n\n    this.ctx.drawImage(\n      this.link,\n      ATTACK_X[direction][frame],\n      ATTACK_Y[direction][frame],\n      attackWidth,\n      attackHeight,\n      attackPosX,\n      attackPosY,\n      attackWidth*this.scale,\n      attackHeight*this.scale,\n    )\n    // this.ctx.beginPath();\n    // this.ctx.rect(this.position[0], this.position[1], attackWidth*this.scale, attackHeight*this.scale)\n    // this.ctx.lineWidth = 1\n    // this.ctx.strokeStyle = 'yellow';\n    // this.ctx.stroke();\n  };\n\n  swing() {\n    if (this.attacking === true) {\n      let numFrames = ATTACK_X[attack_directions[this.currentDirection]].length;\n      let cycleLoop = Array.from({length: numFrames}, (x,i) => i);\n      while (this.attackCurrentLoopIndex <= cycleLoop.length) {\n        if (this.attackFrameCount < 3) {\n          this.drawAttackFrame(\n            attack_directions[this.currentDirection],\n            cycleLoop[this.attackCurrentLoopIndex],\n          );\n          this.attackFrameCount++\n          return;\n        }\n        this.attackFrameCount = 0;\n\n        this.attackCurrentLoopIndex++;\n        if (this.attackCurrentLoopIndex === cycleLoop.length) {\n          break;\n        }\n        // this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n        this.drawAttackFrame(\n          attack_directions[this.currentDirection],\n          cycleLoop[this.attackCurrentLoopIndex],\n        );\n      }\n      this.attackCurrentLoopIndex = 0;\n      this.attacking = false;\n    }\n  }\n\n  attack(e) {\n    if ((this.stunned || this.firingBow || this.attacking) === true) {\n      return;\n    }\n    if (this.keys[72] === true) {\n      const swordSoundIdx = Math.floor(Math.random()*2)\n      this.swordSwingSounds[swordSoundIdx].play();\n      this.walking = false;\n      this.attacking = true;\n    }\n  }\n\n  drawBowFrame(frames) {\n    this.ctx.drawImage(\n      this.link2,\n      frames[0],\n      frames[1],\n      frames[2],\n      frames[3],\n      this.position[0],\n      this.position[1],\n      frames[2]*this.scale,\n      frames[3]*this.scale,\n    )\n  }\n\n  fireBow() {\n    if (this.firingBow === true) {\n      let allFrames = BOW_SPRITES[bow_directions[this.currentDirection]]\n      let numFrames = allFrames.length\n      while (this.bowCurrentLoopIndex < numFrames) {\n        if (this.bowFrameCount < 8) {\n          this.drawBowFrame(allFrames[this.bowCurrentLoopIndex]),\n          this.bowFrameCount++\n          return;\n        }\n        this.bowFrameCount = 0;\n        this.bowCurrentLoopIndex++;\n        if (this.bowCurrentLoopIndex === numFrames) {\n          break;\n        }\n        // this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n        this.drawBowFrame(allFrames[this.bowCurrentLoopIndex]);\n      }\n      this.bowCurrentLoopIndex = 0;\n      this.firingBow = false;\n    }\n  }\n\n  useBow(e) {\n    if ((this.stunned || this.firingBow || this.attacking) === true) {\n      return;\n    }\n    if (this.keys[66] === true && this.ammo > 0) {\n      this.arrowShootSound.play();\n      this.firingBow = true;\n    }\n  }\n\n  drawStand() {\n    this.ctx.drawImage(\n      this.link,\n      STANDING[this.currentDirection][0],\n      STANDING[this.currentDirection][1],\n      this.width,\n      this.height,\n      this.position[0],\n      this.position[1],\n      this.scaledWidth,\n      this.scaledHeight,\n    );\n  }\n\n  stand() {\n    if ((this.walking || this.attacking || this.firingBow) === false) {\n      // this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n      this.drawStand();\n    }\n  }\n\n  preventOffscreen() {\n    if (this.position[0] < 0) {\n      this.position[0] = 0\n    }\n    if (this.position[0] + this.scaledWidth > this.canvas.width) {\n      this.position[0] = this.canvas.width - this.scaledWidth\n    }\n    if (this.position[1] < 0) {\n      this.position[1] = 0\n    }\n    if (this.position[1] + this.scaledHeight > this.canvas.height) {\n      this.position[1] = this.canvas.height - this.scaledHeight\n    }\n  }\n\n  stopWalking(e) {\n    this.walking = false;\n  }\n\n  draw() {\n    this.preventOffscreen();\n    this.swing();\n    this.step();\n    this.fireBow();\n    this.stand();\n    this.invincibility();\n  };\n}\n\nexport default Link;\n","import Game from './game.js';\n\ndocument.addEventListener('DOMContentLoaded', ()=> {\n  const mainCanvas = document.getElementById('main-window');\n  const ctx = mainCanvas.getContext('2d');\n\n  const game = new Game(mainCanvas, ctx)\n  game.loop();\n});\n","import Enemy from './enemy';\n\nconst WALLMASTER_SPRITES = [\n  [280, 883, 24, 22],\n  [318, 883, 24, 22]\n]\n\nclass Wallmaster extends Enemy {\n  constructor(canvas, ctx, pos) {\n    super(canvas, ctx, pos);\n    this.wallmaster = new Image();\n    this.wallmaster.src = './assets/enemies.png';\n    this.currentLoopIndex = 0;\n    this.walkCycle = 0;\n    this.frameCount = -1;\n    this.life = 3;\n    this.scale = 2.6;\n    this.speed = Math.random()*.8;\n\n    this.move = this.move.bind(this);\n  }\n\n  hitbox() {\n    return {\n      x: this.position[0],\n      y: this.position[1],\n      width: 23*this.scale,\n      height: 23*this.scale,\n    }\n  };\n\n  moveTowardsObject(object) {\n    if (object.position[0] < this.position[0]) {\n      this.position[0] -= this.speed;\n      this.currentDirection = 1;\n    }\n    if (object.position[1] < this.position[1]) {\n      this.position[1] -= this.speed;\n      this.currentDirection = 2;\n    }\n    if (object.position[0] > this.position[0]) {\n      this.position[0] += this.speed;\n      this.currentDirection = 0;\n    }\n    if (object.position[1] > this.position[1]) {\n      this.position[1] += this.speed;\n      this.currentDirection = 3;\n    }\n  }\n\n  move(player) {\n    // if (this.currentDirection === 0) {\n    //   this.position[0] += this.speed;\n    //   if (this.position[0] + this.width > this.canvas.width || this.position[0] < 0) {\n    //     this.currentDirection = 1\n    //   }\n    // } else if (this.currentDirection === 1) {\n    //   this.position[0] -= this.speed;\n    //   if (this.position[0] + this.width > this.canvas.width || this.position[0] < 0) {\n    //     this.currentDirection = 0\n    //   }\n    // }\n    this.moveTowardsObject(player)\n  }\n\n  getSprite() {\n    if (this.walkCycle === 0) {\n      return WALLMASTER_SPRITES[0]\n    } else {\n      return WALLMASTER_SPRITES[1]\n    }\n  }\n\n  draw() {\n    if (this.frameCount < 9) {\n      this.frameCount++\n    } else {\n      this.walkCycle = (this.walkCycle === 1 ? 0 : 1)\n      this.frameCount = 0;\n    }\n\n    let sprite = this.getSprite();\n\n    // this.ctx.clearRect(this.position[0], this.position[1], this.hitbox().width, this.hitbox().height)\n    // this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n    this.ctx.drawImage(\n      this.wallmaster,\n      sprite[0],\n      sprite[1],\n      sprite[2],\n      sprite[3],\n      this.position[0],\n      this.position[1],\n      this.scale*sprite[2],\n      this.scale*sprite[3],\n    )\n  }\n}\n\nexport default Wallmaster;\n"],"sourceRoot":""}